[["T_OPEN_TAG","<?php\n",1],["T_DOC_COMMENT","\/**\n * CakePHP(tm) : Rapid Development Framework (http:\/\/cakephp.org)\n * Copyright (c) Cake Software Foundation, Inc. (http:\/\/cakefoundation.org)\n *\n * Licensed under The MIT License\n * For full copyright and license information, please see the LICENSE.txt\n * Redistributions of files must retain the above copyright notice.\n *\n * @copyright     Copyright (c) Cake Software Foundation, Inc. (http:\/\/cakefoundation.org)\n * @link          http:\/\/cakephp.org CakePHP(tm) Project\n * @since         3.1\n * @license       http:\/\/www.opensource.org\/licenses\/mit-license.php MIT License\n *\/",2],["T_WHITESPACE","\n\n",14],["T_NAMESPACE","namespace",16],["T_WHITESPACE"," ",16],["T_STRING","Cake",16],["T_NS_SEPARATOR","\\",16],["T_STRING","Datasource",16],";",["T_WHITESPACE","\n\n",16],["T_DOC_COMMENT","\/**\n * The basis for every query object\n *\n * @package Cake\\Datasource\n *\/",18],["T_WHITESPACE","\n",22],["T_INTERFACE","interface",23],["T_WHITESPACE"," ",23],["T_STRING","QueryInterface",23],["T_WHITESPACE","\n",23],"{",["T_WHITESPACE","\n\n    ",24],["T_DOC_COMMENT","\/**\n     * Returns a key => value array representing a single aliased field\n     * that can be passed directly to the select() method.\n     * The key will contain the alias and the value the actual field name.\n     *\n     * If the field is already aliased, then it will not be changed.\n     * If no $alias is passed, the default table for this query will be used.\n     *\n     * @param string $field The field to alias\n     * @param string|null $alias the alias used to prefix the field\n     * @return array\n     *\/",26],["T_WHITESPACE","\n    ",37],["T_PUBLIC","public",38],["T_WHITESPACE"," ",38],["T_FUNCTION","function",38],["T_WHITESPACE"," ",38],["T_STRING","aliasField",38],"(",["T_VARIABLE","$field",38],",",["T_WHITESPACE"," ",38],["T_VARIABLE","$alias",38],["T_WHITESPACE"," ",38],"=",["T_WHITESPACE"," ",38],["T_STRING","null",38],")",";",["T_WHITESPACE","\n\n    ",38],["T_DOC_COMMENT","\/**\n     * Runs `aliasField()` for each field in the provided list and returns\n     * the result under a single array.\n     *\n     * @param array $fields The fields to alias\n     * @param string|null $defaultAlias The default alias\n     * @return array\n     *\/",40],["T_WHITESPACE","\n    ",47],["T_PUBLIC","public",48],["T_WHITESPACE"," ",48],["T_FUNCTION","function",48],["T_WHITESPACE"," ",48],["T_STRING","aliasFields",48],"(",["T_VARIABLE","$fields",48],",",["T_WHITESPACE"," ",48],["T_VARIABLE","$defaultAlias",48],["T_WHITESPACE"," ",48],"=",["T_WHITESPACE"," ",48],["T_STRING","null",48],")",";",["T_WHITESPACE","\n\n    ",48],["T_DOC_COMMENT","\/**\n     * Fetch the results for this query.\n     *\n     * Will return either the results set through setResult(), or execute this query\n     * and return the ResultSetDecorator object ready for streaming of results.\n     *\n     * ResultSetDecorator is a traversable object that implements the methods found\n     * on Cake\\Collection\\Collection.\n     *\n     * @return \\Cake\\Datasource\\ResultSetInterface\n     *\/",50],["T_WHITESPACE","\n    ",60],["T_PUBLIC","public",61],["T_WHITESPACE"," ",61],["T_FUNCTION","function",61],["T_WHITESPACE"," ",61],["T_STRING","all",61],"(",")",";",["T_WHITESPACE","\n\n    ",61],["T_DOC_COMMENT","\/**\n     * Populates or adds parts to current query clauses using an array.\n     * This is handy for passing all query clauses at once. The option array accepts:\n     *\n     * - fields: Maps to the select method\n     * - conditions: Maps to the where method\n     * - limit: Maps to the limit method\n     * - order: Maps to the order method\n     * - offset: Maps to the offset method\n     * - group: Maps to the group method\n     * - having: Maps to the having method\n     * - contain: Maps to the contain options for eager loading\n     * - join: Maps to the join method\n     * - page: Maps to the page method\n     *\n     * ### Example:\n     *\n     * ```\n     * $query->applyOptions([\n     *   'fields' => ['id', 'name'],\n     *   'conditions' => [\n     *     'created >=' => '2013-01-01'\n     *   ],\n     *   'limit' => 10\n     * ]);\n     * ```\n     *\n     * Is equivalent to:\n     *\n     * ```\n     *  $query\n     *  ->select(['id', 'name'])\n     *  ->where(['created >=' => '2013-01-01'])\n     *  ->limit(10)\n     * ```\n     *\n     * @param array $options list of query clauses to apply new parts to.\n     * @return $this\n     *\/",63],["T_WHITESPACE","\n    ",101],["T_PUBLIC","public",102],["T_WHITESPACE"," ",102],["T_FUNCTION","function",102],["T_WHITESPACE"," ",102],["T_STRING","applyOptions",102],"(",["T_ARRAY","array",102],["T_WHITESPACE"," ",102],["T_VARIABLE","$options",102],")",";",["T_WHITESPACE","\n\n    ",102],["T_DOC_COMMENT","\/**\n     * Apply custom finds to against an existing query object.\n     *\n     * Allows custom find methods to be combined and applied to each other.\n     *\n     * ```\n     * $repository->find('all')->find('recent');\n     * ```\n     *\n     * The above is an example of stacking multiple finder methods onto\n     * a single query.\n     *\n     * @param string $finder The finder method to use.\n     * @param array $options The options for the finder.\n     * @return $this Returns a modified query.\n     *\/",104],["T_WHITESPACE","\n    ",119],["T_PUBLIC","public",120],["T_WHITESPACE"," ",120],["T_FUNCTION","function",120],["T_WHITESPACE"," ",120],["T_STRING","find",120],"(",["T_VARIABLE","$finder",120],",",["T_WHITESPACE"," ",120],["T_ARRAY","array",120],["T_WHITESPACE"," ",120],["T_VARIABLE","$options",120],["T_WHITESPACE"," ",120],"=",["T_WHITESPACE"," ",120],"[","]",")",";",["T_WHITESPACE","\n\n    ",120],["T_DOC_COMMENT","\/**\n     * Returns the first result out of executing this query, if the query has not been\n     * executed before, it will set the limit clause to 1 for performance reasons.\n     *\n     * ### Example:\n     *\n     * ```\n     * $singleUser = $query->select(['id', 'username'])->first();\n     * ```\n     *\n     * @return mixed the first result from the ResultSet\n     *\/",122],["T_WHITESPACE","\n    ",133],["T_PUBLIC","public",134],["T_WHITESPACE"," ",134],["T_FUNCTION","function",134],["T_WHITESPACE"," ",134],["T_STRING","first",134],"(",")",";",["T_WHITESPACE","\n\n    ",134],["T_DOC_COMMENT","\/**\n     * Returns the total amount of results for the query.\n     *\n     * @return int\n     *\/",136],["T_WHITESPACE","\n    ",140],["T_PUBLIC","public",141],["T_WHITESPACE"," ",141],["T_FUNCTION","function",141],["T_WHITESPACE"," ",141],["T_STRING","count",141],"(",")",";",["T_WHITESPACE","\n\n    ",141],["T_DOC_COMMENT","\/**\n     * Sets the number of records that should be retrieved from database,\n     * accepts an integer or an expression object that evaluates to an integer.\n     * In some databases, this operation might not be supported or will require\n     * the query to be transformed in order to limit the result set size.\n     *\n     * ### Examples\n     *\n     * ```\n     * $query->limit(10) \/\/ generates LIMIT 10\n     * $query->limit($query->newExpr()->add(['1 + 1'])); \/\/ LIMIT (1 + 1)\n     * ```\n     *\n     * @param int $num number of records to be returned\n     * @return $this\n     *\/",143],["T_WHITESPACE","\n    ",158],["T_PUBLIC","public",159],["T_WHITESPACE"," ",159],["T_FUNCTION","function",159],["T_WHITESPACE"," ",159],["T_STRING","limit",159],"(",["T_VARIABLE","$num",159],")",";",["T_WHITESPACE","\n\n    ",159],["T_DOC_COMMENT","\/**\n     * Sets the number of records that should be skipped from the original result set\n     * This is commonly used for paginating large results. Accepts an integer or an\n     * expression object that evaluates to an integer.\n     *\n     * In some databases, this operation might not be supported or will require\n     * the query to be transformed in order to limit the result set size.\n     *\n     * ### Examples\n     *\n     * ```\n     *  $query->offset(10) \/\/ generates OFFSET 10\n     *  $query->offset($query->newExpr()->add(['1 + 1'])); \/\/ OFFSET (1 + 1)\n     * ```\n     *\n     * @param int $num number of records to be skipped\n     * @return $this\n     *\/",161],["T_WHITESPACE","\n    ",178],["T_PUBLIC","public",179],["T_WHITESPACE"," ",179],["T_FUNCTION","function",179],["T_WHITESPACE"," ",179],["T_STRING","offset",179],"(",["T_VARIABLE","$num",179],")",";",["T_WHITESPACE","\n\n    ",179],["T_DOC_COMMENT","\/**\n     * Adds a single or multiple fields to be used in the ORDER clause for this query.\n     * Fields can be passed as an array of strings, array of expression\n     * objects, a single expression or a single string.\n     *\n     * If an array is passed, keys will be used as the field itself and the value will\n     * represent the order in which such field should be ordered. When called multiple\n     * times with the same fields as key, the last order definition will prevail over\n     * the others.\n     *\n     * By default this function will append any passed argument to the list of fields\n     * to be selected, unless the second argument is set to true.\n     *\n     * ### Examples:\n     *\n     * ```\n     * $query->order(['title' => 'DESC', 'author_id' => 'ASC']);\n     * ```\n     *\n     * Produces:\n     *\n     * `ORDER BY title DESC, author_id ASC`\n     *\n     * ```\n     * $query->order(['title' => 'DESC NULLS FIRST'])->order('author_id');\n     * ```\n     *\n     * Will generate:\n     *\n     * `ORDER BY title DESC NULLS FIRST, author_id`\n     *\n     * ```\n     * $expression = $query->newExpr()->add(['id % 2 = 0']);\n     * $query->order($expression)->order(['title' => 'ASC']);\n     * ```\n     *\n     * Will become:\n     *\n     * `ORDER BY (id %2 = 0), title ASC`\n     *\n     * If you need to set complex expressions as order conditions, you\n     * should use `orderAsc()` or `orderDesc()`.\n     *\n     * @param array|string $fields fields to be added to the list\n     * @param bool $overwrite whether to reset order with field list or not\n     * @return $this\n     *\/",181],["T_WHITESPACE","\n    ",227],["T_PUBLIC","public",228],["T_WHITESPACE"," ",228],["T_FUNCTION","function",228],["T_WHITESPACE"," ",228],["T_STRING","order",228],"(",["T_VARIABLE","$fields",228],",",["T_WHITESPACE"," ",228],["T_VARIABLE","$overwrite",228],["T_WHITESPACE"," ",228],"=",["T_WHITESPACE"," ",228],["T_STRING","false",228],")",";",["T_WHITESPACE","\n\n    ",228],["T_DOC_COMMENT","\/**\n     * Set the page of results you want.\n     *\n     * This method provides an easier to use interface to set the limit + offset\n     * in the record set you want as results. If empty the limit will default to\n     * the existing limit clause, and if that too is empty, then `25` will be used.\n     *\n     * Pages should start at 1.\n     *\n     * @param int $num The page number you want.\n     * @param int|null $limit The number of rows you want in the page. If null\n     *  the current limit clause will be used.\n     * @return $this\n     *\/",230],["T_WHITESPACE","\n    ",243],["T_PUBLIC","public",244],["T_WHITESPACE"," ",244],["T_FUNCTION","function",244],["T_WHITESPACE"," ",244],["T_STRING","page",244],"(",["T_VARIABLE","$num",244],",",["T_WHITESPACE"," ",244],["T_VARIABLE","$limit",244],["T_WHITESPACE"," ",244],"=",["T_WHITESPACE"," ",244],["T_STRING","null",244],")",";",["T_WHITESPACE","\n\n    ",244],["T_DOC_COMMENT","\/**\n     * Returns an array representation of the results after executing the query.\n     *\n     * @return array\n     *\/",246],["T_WHITESPACE","\n    ",250],["T_PUBLIC","public",251],["T_WHITESPACE"," ",251],["T_FUNCTION","function",251],["T_WHITESPACE"," ",251],["T_STRING","toArray",251],"(",")",";",["T_WHITESPACE","\n\n    ",251],["T_DOC_COMMENT","\/**\n     * Returns the default repository object that will be used by this query,\n     * that is, the repository that will appear in the from clause.\n     *\n     * @param \\Cake\\Datasource\\RepositoryInterface|null $repository The default repository object to use\n     * @return \\Cake\\Datasource\\RepositoryInterface|$this\n     *\/",253],["T_WHITESPACE","\n    ",259],["T_PUBLIC","public",260],["T_WHITESPACE"," ",260],["T_FUNCTION","function",260],["T_WHITESPACE"," ",260],["T_STRING","repository",260],"(",["T_STRING","RepositoryInterface",260],["T_WHITESPACE"," ",260],["T_VARIABLE","$repository",260],["T_WHITESPACE"," ",260],"=",["T_WHITESPACE"," ",260],["T_STRING","null",260],")",";",["T_WHITESPACE","\n\n    ",260],["T_DOC_COMMENT","\/**\n     * Adds a condition or set of conditions to be used in the WHERE clause for this\n     * query. Conditions can be expressed as an array of fields as keys with\n     * comparison operators in it, the values for the array will be used for comparing\n     * the field to such literal. Finally, conditions can be expressed as a single\n     * string or an array of strings.\n     *\n     * When using arrays, each entry will be joined to the rest of the conditions using\n     * an AND operator. Consecutive calls to this function will also join the new\n     * conditions specified using the AND operator. Additionally, values can be\n     * expressed using expression objects which can include other query objects.\n     *\n     * Any conditions created with this methods can be used with any SELECT, UPDATE\n     * and DELETE type of queries.\n     *\n     * ### Conditions using operators:\n     *\n     * ```\n     *  $query->where([\n     *      'posted >=' => new DateTime('3 days ago'),\n     *      'title LIKE' => 'Hello W%',\n     *      'author_id' => 1,\n     *  ], ['posted' => 'datetime']);\n     * ```\n     *\n     * The previous example produces:\n     *\n     * `WHERE posted >= 2012-01-27 AND title LIKE 'Hello W%' AND author_id = 1`\n     *\n     * Second parameter is used to specify what type is expected for each passed\n     * key. Valid types can be used from the mapped with Database\\Type class.\n     *\n     * ### Nesting conditions with conjunctions:\n     *\n     * ```\n     *  $query->where([\n     *      'author_id !=' => 1,\n     *      'OR' => ['published' => true, 'posted <' => new DateTime('now')],\n     *      'NOT' => ['title' => 'Hello']\n     *  ], ['published' => boolean, 'posted' => 'datetime']\n     * ```\n     *\n     * The previous example produces:\n     *\n     * `WHERE author_id = 1 AND (published = 1 OR posted < '2012-02-01') AND NOT (title = 'Hello')`\n     *\n     * You can nest conditions using conjunctions as much as you like. Sometimes, you\n     * may want to define 2 different options for the same key, in that case, you can\n     * wrap each condition inside a new array:\n     *\n     * `$query->where(['OR' => [['published' => false], ['published' => true]])`\n     *\n     * Keep in mind that every time you call where() with the third param set to false\n     * (default), it will join the passed conditions to the previous stored list using\n     * the AND operator. Also, using the same array key twice in consecutive calls to\n     * this method will not override the previous value.\n     *\n     * ### Using expressions objects:\n     *\n     * ```\n     *  $exp = $query->newExpr()->add(['id !=' => 100, 'author_id' != 1])->tieWith('OR');\n     *  $query->where(['published' => true], ['published' => 'boolean'])->where($exp);\n     * ```\n     *\n     * The previous example produces:\n     *\n     * `WHERE (id != 100 OR author_id != 1) AND published = 1`\n     *\n     * Other Query objects that be used as conditions for any field.\n     *\n     * ### Adding conditions in multiple steps:\n     *\n     * You can use callable functions to construct complex expressions, functions\n     * receive as first argument a new QueryExpression object and this query instance\n     * as second argument. Functions must return an expression object, that will be\n     * added the list of conditions for the query using the AND operator.\n     *\n     * ```\n     *  $query\n     *  ->where(['title !=' => 'Hello World'])\n     *  ->where(function ($exp, $query) {\n     *      $or = $exp->or_(['id' => 1]);\n     *      $and = $exp->and_(['id >' => 2, 'id <' => 10]);\n     *  return $or->add($and);\n     *  });\n     * ```\n     *\n     * * The previous example produces:\n     *\n     * `WHERE title != 'Hello World' AND (id = 1 OR (id > 2 AND id < 10))`\n     *\n     * ### Conditions as strings:\n     *\n     * ```\n     *  $query->where(['articles.author_id = authors.id', 'modified IS NULL']);\n     * ```\n     *\n     * The previous example produces:\n     *\n     * `WHERE articles.author_id = authors.id AND modified IS NULL`\n     *\n     * Please note that when using the array notation or the expression objects, all\n     * values will be correctly quoted and transformed to the correspondent database\n     * data type automatically for you, thus securing your application from SQL injections.\n     * If you use string conditions make sure that your values are correctly quoted.\n     * The safest thing you can do is to never use string conditions.\n     *\n     * @param string|array|callable|null $conditions The conditions to filter on.\n     * @param array $types associative array of type names used to bind values to query\n     * @param bool $overwrite whether to reset conditions with passed list or not\n     * @return $this\n     *\/",262],["T_WHITESPACE","\n    ",373],["T_PUBLIC","public",374],["T_WHITESPACE"," ",374],["T_FUNCTION","function",374],["T_WHITESPACE"," ",374],["T_STRING","where",374],"(",["T_VARIABLE","$conditions",374],["T_WHITESPACE"," ",374],"=",["T_WHITESPACE"," ",374],["T_STRING","null",374],",",["T_WHITESPACE"," ",374],["T_VARIABLE","$types",374],["T_WHITESPACE"," ",374],"=",["T_WHITESPACE"," ",374],"[","]",",",["T_WHITESPACE"," ",374],["T_VARIABLE","$overwrite",374],["T_WHITESPACE"," ",374],"=",["T_WHITESPACE"," ",374],["T_STRING","false",374],")",";",["T_WHITESPACE","\n",374],"}",["T_WHITESPACE","\n",375]]