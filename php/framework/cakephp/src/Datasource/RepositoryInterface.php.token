[["T_OPEN_TAG","<?php\n",1],["T_DOC_COMMENT","\/**\n * CakePHP(tm) : Rapid Development Framework (http:\/\/cakephp.org)\n * Copyright (c) Cake Software Foundation, Inc. (http:\/\/cakefoundation.org)\n *\n * Licensed under The MIT License\n * For full copyright and license information, please see the LICENSE.txt\n * Redistributions of files must retain the above copyright notice.\n *\n * @copyright     Copyright (c) Cake Software Foundation, Inc. (http:\/\/cakefoundation.org)\n * @link          http:\/\/cakephp.org CakePHP(tm) Project\n * @since         3.0.0\n * @license       http:\/\/www.opensource.org\/licenses\/mit-license.php MIT License\n *\/",2],["T_WHITESPACE","\n",14],["T_NAMESPACE","namespace",15],["T_WHITESPACE"," ",15],["T_STRING","Cake",15],["T_NS_SEPARATOR","\\",15],["T_STRING","Datasource",15],";",["T_WHITESPACE","\n\n",15],["T_DOC_COMMENT","\/**\n * Describes the methods that any class representing a data storage should\n * comply with.\n *\/",17],["T_WHITESPACE","\n",20],["T_INTERFACE","interface",21],["T_WHITESPACE"," ",21],["T_STRING","RepositoryInterface",21],["T_WHITESPACE","\n",21],"{",["T_WHITESPACE","\n\n    ",22],["T_DOC_COMMENT","\/**\n     * Returns the table alias or sets a new one\n     *\n     * @param string|null $alias the new table alias\n     * @return string\n     *\/",24],["T_WHITESPACE","\n    ",29],["T_PUBLIC","public",30],["T_WHITESPACE"," ",30],["T_FUNCTION","function",30],["T_WHITESPACE"," ",30],["T_STRING","alias",30],"(",["T_VARIABLE","$alias",30],["T_WHITESPACE"," ",30],"=",["T_WHITESPACE"," ",30],["T_STRING","null",30],")",";",["T_WHITESPACE","\n\n    ",30],["T_DOC_COMMENT","\/**\n     * Test to see if a Repository has a specific field\/column.\n     *\n     * @param string $field The field to check for.\n     * @return bool True if the field exists, false if it does not.\n     *\/",32],["T_WHITESPACE","\n    ",37],["T_PUBLIC","public",38],["T_WHITESPACE"," ",38],["T_FUNCTION","function",38],["T_WHITESPACE"," ",38],["T_STRING","hasField",38],"(",["T_VARIABLE","$field",38],")",";",["T_WHITESPACE","\n\n    ",38],["T_DOC_COMMENT","\/**\n     * Creates a new Query for this repository and applies some defaults based on the\n     * type of search that was selected.\n     *\n     * ### Model.beforeFind event\n     *\n     * Each find() will trigger a `Model.beforeFind` event for all attached\n     * listeners. Any listener can set a valid result set using $query\n     *\n     * @param string $type the type of query to perform\n     * @param array|\\ArrayAccess $options An array that will be passed to Query::applyOptions()\n     * @return \\Cake\\ORM\\Query\n     *\/",40],["T_WHITESPACE","\n    ",52],["T_PUBLIC","public",53],["T_WHITESPACE"," ",53],["T_FUNCTION","function",53],["T_WHITESPACE"," ",53],["T_STRING","find",53],"(",["T_VARIABLE","$type",53],["T_WHITESPACE"," ",53],"=",["T_WHITESPACE"," ",53],["T_CONSTANT_ENCAPSED_STRING","'all'",53],",",["T_WHITESPACE"," ",53],["T_VARIABLE","$options",53],["T_WHITESPACE"," ",53],"=",["T_WHITESPACE"," ",53],"[","]",")",";",["T_WHITESPACE","\n\n    ",53],["T_DOC_COMMENT","\/**\n     * Returns a single record after finding it by its primary key, if no record is\n     * found this method throws an exception.\n     *\n     * ### Example:\n     *\n     * ```\n     * $id = 10;\n     * $article = $articles->get($id);\n     *\n     * $article = $articles->get($id, ['contain' => ['Comments]]);\n     * ```\n     *\n     * @param mixed $primaryKey primary key value to find\n     * @param array|\\ArrayAccess $options options accepted by `Table::find()`\n     * @throws \\Cake\\Datasource\\Exception\\RecordNotFoundException if the record with such id\n     * could not be found\n     * @return \\Cake\\Datasource\\EntityInterface\n     * @see \\Cake\\Datasource\\RepositoryInterface::find()\n     *\/",55],["T_WHITESPACE","\n    ",74],["T_PUBLIC","public",75],["T_WHITESPACE"," ",75],["T_FUNCTION","function",75],["T_WHITESPACE"," ",75],["T_STRING","get",75],"(",["T_VARIABLE","$primaryKey",75],",",["T_WHITESPACE"," ",75],["T_VARIABLE","$options",75],["T_WHITESPACE"," ",75],"=",["T_WHITESPACE"," ",75],"[","]",")",";",["T_WHITESPACE","\n\n    ",75],["T_DOC_COMMENT","\/**\n     * Creates a new Query instance for this repository\n     *\n     * @return \\Cake\\ORM\\Query\n     *\/",77],["T_WHITESPACE","\n    ",81],["T_PUBLIC","public",82],["T_WHITESPACE"," ",82],["T_FUNCTION","function",82],["T_WHITESPACE"," ",82],["T_STRING","query",82],"(",")",";",["T_WHITESPACE","\n\n    ",82],["T_DOC_COMMENT","\/**\n     * Update all matching records.\n     *\n     * Sets the $fields to the provided values based on $conditions.\n     * This method will *not* trigger beforeSave\/afterSave events. If you need those\n     * first load a collection of records and update them.\n     *\n     * @param string|array|callable|\\Cake\\Database\\Expression\\QueryExpression $fields A hash of field => new value.\n     * @param mixed $conditions Conditions to be used, accepts anything Query::where()\n     * can take.\n     * @return int Count Returns the affected rows.\n     *\/",84],["T_WHITESPACE","\n    ",95],["T_PUBLIC","public",96],["T_WHITESPACE"," ",96],["T_FUNCTION","function",96],["T_WHITESPACE"," ",96],["T_STRING","updateAll",96],"(",["T_VARIABLE","$fields",96],",",["T_WHITESPACE"," ",96],["T_VARIABLE","$conditions",96],")",";",["T_WHITESPACE","\n\n    ",96],["T_DOC_COMMENT","\/**\n     * Deletes all records matching the provided conditions.\n     *\n     * This method will *not* trigger beforeDelete\/afterDelete events. If you\n     * need those first load a collection of records and delete them.\n     *\n     * This method will *not* execute on associations' `cascade` attribute. You should\n     * use database foreign keys + ON CASCADE rules if you need cascading deletes combined\n     * with this method.\n     *\n     * @param mixed $conditions Conditions to be used, accepts anything Query::where()\n     * can take.\n     * @return int Returns the number of affected rows.\n     * @see \\Cake\\Datasource\\RepositoryInterface::delete()\n     *\/",98],["T_WHITESPACE","\n    ",112],["T_PUBLIC","public",113],["T_WHITESPACE"," ",113],["T_FUNCTION","function",113],["T_WHITESPACE"," ",113],["T_STRING","deleteAll",113],"(",["T_VARIABLE","$conditions",113],")",";",["T_WHITESPACE","\n\n    ",113],["T_DOC_COMMENT","\/**\n     * Returns true if there is any record in this repository matching the specified\n     * conditions.\n     *\n     * @param array|\\ArrayAccess $conditions list of conditions to pass to the query\n     * @return bool\n     *\/",115],["T_WHITESPACE","\n    ",121],["T_PUBLIC","public",122],["T_WHITESPACE"," ",122],["T_FUNCTION","function",122],["T_WHITESPACE"," ",122],["T_STRING","exists",122],"(",["T_VARIABLE","$conditions",122],")",";",["T_WHITESPACE","\n\n    ",122],["T_DOC_COMMENT","\/**\n     * Persists an entity based on the fields that are marked as dirty and\n     * returns the same entity after a successful save or false in case\n     * of any error.\n     *\n     * @param \\Cake\\Datasource\\EntityInterface $entity the entity to be saved\n     * @param array|\\ArrayAccess $options The options to use when saving.\n     * @return \\Cake\\Datasource\\EntityInterface|bool\n     *\/",124],["T_WHITESPACE","\n    ",132],["T_PUBLIC","public",133],["T_WHITESPACE"," ",133],["T_FUNCTION","function",133],["T_WHITESPACE"," ",133],["T_STRING","save",133],"(",["T_STRING","EntityInterface",133],["T_WHITESPACE"," ",133],["T_VARIABLE","$entity",133],",",["T_WHITESPACE"," ",133],["T_VARIABLE","$options",133],["T_WHITESPACE"," ",133],"=",["T_WHITESPACE"," ",133],"[","]",")",";",["T_WHITESPACE","\n\n    ",133],["T_DOC_COMMENT","\/**\n     * Delete a single entity.\n     *\n     * Deletes an entity and possibly related associations from the database\n     * based on the 'dependent' option used when defining the association.\n     *\n     * @param \\Cake\\Datasource\\EntityInterface $entity The entity to remove.\n     * @param array|\\ArrayAccess $options The options for the delete.\n     * @return bool success\n     *\/",135],["T_WHITESPACE","\n    ",144],["T_PUBLIC","public",145],["T_WHITESPACE"," ",145],["T_FUNCTION","function",145],["T_WHITESPACE"," ",145],["T_STRING","delete",145],"(",["T_STRING","EntityInterface",145],["T_WHITESPACE"," ",145],["T_VARIABLE","$entity",145],",",["T_WHITESPACE"," ",145],["T_VARIABLE","$options",145],["T_WHITESPACE"," ",145],"=",["T_WHITESPACE"," ",145],"[","]",")",";",["T_WHITESPACE","\n\n    ",145],["T_DOC_COMMENT","\/**\n     * Create a new entity + associated entities from an array.\n     *\n     * This is most useful when hydrating request data back into entities.\n     * For example, in your controller code:\n     *\n     * ```\n     * $article = $this->Articles->newEntity($this->request->data());\n     * ```\n     *\n     * The hydrated entity will correctly do an insert\/update based\n     * on the primary key data existing in the database when the entity\n     * is saved. Until the entity is saved, it will be a detached record.\n     *\n     * @param array|null $data The data to build an entity with.\n     * @param array $options A list of options for the object hydration.\n     * @return \\Cake\\Datasource\\EntityInterface\n     *\/",147],["T_WHITESPACE","\n    ",164],["T_PUBLIC","public",165],["T_WHITESPACE"," ",165],["T_FUNCTION","function",165],["T_WHITESPACE"," ",165],["T_STRING","newEntity",165],"(",["T_VARIABLE","$data",165],["T_WHITESPACE"," ",165],"=",["T_WHITESPACE"," ",165],["T_STRING","null",165],",",["T_WHITESPACE"," ",165],["T_ARRAY","array",165],["T_WHITESPACE"," ",165],["T_VARIABLE","$options",165],["T_WHITESPACE"," ",165],"=",["T_WHITESPACE"," ",165],"[","]",")",";",["T_WHITESPACE","\n\n    ",165],["T_DOC_COMMENT","\/**\n     * Create a list of entities + associated entities from an array.\n     *\n     * This is most useful when hydrating request data back into entities.\n     * For example, in your controller code:\n     *\n     * ```\n     * $articles = $this->Articles->newEntities($this->request->data());\n     * ```\n     *\n     * The hydrated entities can then be iterated and saved.\n     *\n     * @param array $data The data to build an entity with.\n     * @param array $options A list of options for the objects hydration.\n     * @return array An array of hydrated records.\n     *\/",167],["T_WHITESPACE","\n    ",182],["T_PUBLIC","public",183],["T_WHITESPACE"," ",183],["T_FUNCTION","function",183],["T_WHITESPACE"," ",183],["T_STRING","newEntities",183],"(",["T_ARRAY","array",183],["T_WHITESPACE"," ",183],["T_VARIABLE","$data",183],",",["T_WHITESPACE"," ",183],["T_ARRAY","array",183],["T_WHITESPACE"," ",183],["T_VARIABLE","$options",183],["T_WHITESPACE"," ",183],"=",["T_WHITESPACE"," ",183],"[","]",")",";",["T_WHITESPACE","\n\n    ",183],["T_DOC_COMMENT","\/**\n     * Merges the passed `$data` into `$entity` respecting the accessible\n     * fields configured on the entity. Returns the same entity after being\n     * altered.\n     *\n     * This is most useful when editing an existing entity using request data:\n     *\n     * ```\n     * $article = $this->Articles->patchEntity($article, $this->request->data());\n     * ```\n     *\n     * @param \\Cake\\Datasource\\EntityInterface $entity the entity that will get the\n     * data merged in\n     * @param array $data key value list of fields to be merged into the entity\n     * @param array $options A list of options for the object hydration.\n     * @return \\Cake\\Datasource\\EntityInterface\n     *\/",185],["T_WHITESPACE","\n    ",201],["T_PUBLIC","public",202],["T_WHITESPACE"," ",202],["T_FUNCTION","function",202],["T_WHITESPACE"," ",202],["T_STRING","patchEntity",202],"(",["T_STRING","EntityInterface",202],["T_WHITESPACE"," ",202],["T_VARIABLE","$entity",202],",",["T_WHITESPACE"," ",202],["T_ARRAY","array",202],["T_WHITESPACE"," ",202],["T_VARIABLE","$data",202],",",["T_WHITESPACE"," ",202],["T_ARRAY","array",202],["T_WHITESPACE"," ",202],["T_VARIABLE","$options",202],["T_WHITESPACE"," ",202],"=",["T_WHITESPACE"," ",202],"[","]",")",";",["T_WHITESPACE","\n\n    ",202],["T_DOC_COMMENT","\/**\n     * Merges each of the elements passed in `$data` into the entities\n     * found in `$entities` respecting the accessible fields configured on the entities.\n     * Merging is done by matching the primary key in each of the elements in `$data`\n     * and `$entities`.\n     *\n     * This is most useful when editing a list of existing entities using request data:\n     *\n     * ```\n     * $article = $this->Articles->patchEntities($articles, $this->request->data());\n     * ```\n     *\n     * @param array|\\Traversable $entities the entities that will get the\n     * data merged in\n     * @param array $data list of arrays to be merged into the entities\n     * @param array $options A list of options for the objects hydration.\n     * @return array\n     *\/",204],["T_WHITESPACE","\n    ",221],["T_PUBLIC","public",222],["T_WHITESPACE"," ",222],["T_FUNCTION","function",222],["T_WHITESPACE"," ",222],["T_STRING","patchEntities",222],"(",["T_VARIABLE","$entities",222],",",["T_WHITESPACE"," ",222],["T_ARRAY","array",222],["T_WHITESPACE"," ",222],["T_VARIABLE","$data",222],",",["T_WHITESPACE"," ",222],["T_ARRAY","array",222],["T_WHITESPACE"," ",222],["T_VARIABLE","$options",222],["T_WHITESPACE"," ",222],"=",["T_WHITESPACE"," ",222],"[","]",")",";",["T_WHITESPACE","\n",222],"}",["T_WHITESPACE","\n",223]]