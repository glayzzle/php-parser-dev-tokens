[["T_OPEN_TAG","<?php\n",1],["T_DOC_COMMENT","\/**\n * CakePHP(tm) : Rapid Development Framework (http:\/\/cakephp.org)\n * Copyright (c) Cake Software Foundation, Inc. (http:\/\/cakefoundation.org)\n *\n * Licensed under The MIT License\n * For full copyright and license information, please see the LICENSE.txt\n * Redistributions of files must retain the above copyright notice.\n *\n * @copyright     Copyright (c) Cake Software Foundation, Inc. (http:\/\/cakefoundation.org)\n * @link          http:\/\/cakephp.org CakePHP(tm) Project\n * @since         3.0.0\n * @license       http:\/\/www.opensource.org\/licenses\/mit-license.php MIT License\n *\/",2],["T_WHITESPACE","\n",14],["T_NAMESPACE","namespace",15],["T_WHITESPACE"," ",15],["T_STRING","Cake",15],["T_NS_SEPARATOR","\\",15],["T_STRING","Collection",15],";",["T_WHITESPACE","\n\n",15],["T_USE","use",17],["T_WHITESPACE"," ",17],["T_STRING","Iterator",17],";",["T_WHITESPACE","\n",17],["T_USE","use",18],["T_WHITESPACE"," ",18],["T_STRING","JsonSerializable",18],";",["T_WHITESPACE","\n\n",18],["T_DOC_COMMENT","\/**\n * Describes the methods a Collection should implement. A collection is an immutable\n * list of elements exposing a number of traversing and extracting method for\n * generating other collections.\n *\/",20],["T_WHITESPACE","\n",24],["T_INTERFACE","interface",25],["T_WHITESPACE"," ",25],["T_STRING","CollectionInterface",25],["T_WHITESPACE"," ",25],["T_EXTENDS","extends",25],["T_WHITESPACE"," ",25],["T_STRING","Iterator",25],",",["T_WHITESPACE"," ",25],["T_STRING","JsonSerializable",25],["T_WHITESPACE","\n",25],"{",["T_WHITESPACE","\n\n    ",26],["T_DOC_COMMENT","\/**\n     * Executes the passed callable for each of the elements in this collection\n     * and passes both the value and key for them on each step.\n     * Returns the same collection for chaining.\n     *\n     * ### Example:\n     *\n     * ```\n     * $collection = (new Collection($items))->each(function ($value, $key) {\n     *  echo \"Element $key: $value\";\n     * });\n     * ```\n     *\n     * @param callable $c callable function that will receive each of the elements\n     * in this collection\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",28],["T_WHITESPACE","\n    ",44],["T_PUBLIC","public",45],["T_WHITESPACE"," ",45],["T_FUNCTION","function",45],["T_WHITESPACE"," ",45],["T_STRING","each",45],"(",["T_CALLABLE","callable",45],["T_WHITESPACE"," ",45],["T_VARIABLE","$c",45],")",";",["T_WHITESPACE","\n\n    ",45],["T_DOC_COMMENT","\/**\n     * Looks through each value in the collection, and returns another collection with\n     * all the values that pass a truth test. Only the values for which the callback\n     * returns true will be present in the resulting collection.\n     *\n     * Each time the callback is executed it will receive the value of the element\n     * in the current iteration, the key of the element and this collection as\n     * arguments, in that order.\n     *\n     * ### Example:\n     *\n     * Filtering odd numbers in an array, at the end only the value 2 will\n     * be present in the resulting collection:\n     *\n     * ```\n     * $collection = (new Collection([1, 2, 3]))->filter(function ($value, $key) {\n     *  return $value % 2 === 0;\n     * });\n     * ```\n     *\n     * @param callable|null $c the method that will receive each of the elements and\n     *   returns true whether or not they should be in the resulting collection.\n     *   If left null, a callback that filters out falsey values will be used.\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",47],["T_WHITESPACE","\n    ",71],["T_PUBLIC","public",72],["T_WHITESPACE"," ",72],["T_FUNCTION","function",72],["T_WHITESPACE"," ",72],["T_STRING","filter",72],"(",["T_CALLABLE","callable",72],["T_WHITESPACE"," ",72],["T_VARIABLE","$c",72],["T_WHITESPACE"," ",72],"=",["T_WHITESPACE"," ",72],["T_STRING","null",72],")",";",["T_WHITESPACE","\n\n    ",72],["T_DOC_COMMENT","\/**\n     * Looks through each value in the collection, and returns another collection with\n     * all the values that do not pass a truth test. This is the opposite of `filter`.\n     *\n     * Each time the callback is executed it will receive the value of the element\n     * in the current iteration, the key of the element and this collection as\n     * arguments, in that order.\n     *\n     * ### Example:\n     *\n     * Filtering even numbers in an array, at the end only values 1 and 3 will\n     * be present in the resulting collection:\n     *\n     * ```\n     * $collection = (new Collection([1, 2, 3]))->reject(function ($value, $key) {\n     *  return $value % 2 === 0;\n     * });\n     * ```\n     *\n     * @param callable $c the method that will receive each of the elements and\n     * returns true whether or not they should be out of the resulting collection.\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",74],["T_WHITESPACE","\n    ",96],["T_PUBLIC","public",97],["T_WHITESPACE"," ",97],["T_FUNCTION","function",97],["T_WHITESPACE"," ",97],["T_STRING","reject",97],"(",["T_CALLABLE","callable",97],["T_WHITESPACE"," ",97],["T_VARIABLE","$c",97],")",";",["T_WHITESPACE","\n\n    ",97],["T_DOC_COMMENT","\/**\n     * Returns true if all values in this collection pass the truth test provided\n     * in the callback.\n     *\n     * Each time the callback is executed it will receive the value of the element\n     * in the current iteration and  the key of the element as arguments, in that\n     * order.\n     *\n     * ### Example:\n     *\n     * ```\n     * $overTwentyOne = (new Collection([24, 45, 60, 15]))->every(function ($value, $key) {\n     *  return $value > 21;\n     * });\n     * ```\n     *\n     * @param callable $c a callback function\n     * @return bool true if for all elements in this collection the provided\n     * callback returns true, false otherwise\n     *\/",99],["T_WHITESPACE","\n    ",118],["T_PUBLIC","public",119],["T_WHITESPACE"," ",119],["T_FUNCTION","function",119],["T_WHITESPACE"," ",119],["T_STRING","every",119],"(",["T_CALLABLE","callable",119],["T_WHITESPACE"," ",119],["T_VARIABLE","$c",119],")",";",["T_WHITESPACE","\n\n    ",119],["T_DOC_COMMENT","\/**\n     * Returns true if any of the values in this collection pass the truth test\n     * provided in the callback.\n     *\n     * Each time the callback is executed it will receive the value of the element\n     * in the current iteration and the key of the element as arguments, in that\n     * order.\n     *\n     * ### Example:\n     *\n     * ```\n     * $hasYoungPeople = (new Collection([24, 45, 15]))->every(function ($value, $key) {\n     *  return $value < 21;\n     * });\n     * ```\n     *\n     * @param callable $c a callback function\n     * @return bool true if the provided callback returns true for any element in this\n     * collection, false otherwise\n     *\/",121],["T_WHITESPACE","\n    ",140],["T_PUBLIC","public",141],["T_WHITESPACE"," ",141],["T_FUNCTION","function",141],["T_WHITESPACE"," ",141],["T_STRING","some",141],"(",["T_CALLABLE","callable",141],["T_WHITESPACE"," ",141],["T_VARIABLE","$c",141],")",";",["T_WHITESPACE","\n\n    ",141],["T_DOC_COMMENT","\/**\n     * Returns true if $value is present in this collection. Comparisons are made\n     * both by value and type.\n     *\n     * @param mixed $value The value to check for\n     * @return bool true if $value is present in this collection\n     *\/",143],["T_WHITESPACE","\n    ",149],["T_PUBLIC","public",150],["T_WHITESPACE"," ",150],["T_FUNCTION","function",150],["T_WHITESPACE"," ",150],["T_STRING","contains",150],"(",["T_VARIABLE","$value",150],")",";",["T_WHITESPACE","\n\n    ",150],["T_DOC_COMMENT","\/**\n     * Returns another collection after modifying each of the values in this one using\n     * the provided callable.\n     *\n     * Each time the callback is executed it will receive the value of the element\n     * in the current iteration, the key of the element and this collection as\n     * arguments, in that order.\n     *\n     * ### Example:\n     *\n     * Getting a collection of booleans where true indicates if a person is female:\n     *\n     * ```\n     * $collection = (new Collection($people))->map(function ($person, $key) {\n     *  return $person->gender === 'female';\n     * });\n     * ```\n     *\n     * @param callable $c the method that will receive each of the elements and\n     * returns the new value for the key that is being iterated\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",152],["T_WHITESPACE","\n    ",173],["T_PUBLIC","public",174],["T_WHITESPACE"," ",174],["T_FUNCTION","function",174],["T_WHITESPACE"," ",174],["T_STRING","map",174],"(",["T_CALLABLE","callable",174],["T_WHITESPACE"," ",174],["T_VARIABLE","$c",174],")",";",["T_WHITESPACE","\n\n    ",174],["T_DOC_COMMENT","\/**\n     * Folds the values in this collection to a single value, as the result of\n     * applying the callback function to all elements. $zero is the initial state\n     * of the reduction, and each successive step of it should be returned\n     * by the callback function.\n     * If $zero is omitted the first value of the collection will be used in its place\n     * and reduction will start from the second item.\n     *\n     * @param callable $c The callback function to be called\n     * @param mixed $zero The state of reduction\n     * @return mixed\n     *\/",176],["T_WHITESPACE","\n    ",187],["T_PUBLIC","public",188],["T_WHITESPACE"," ",188],["T_FUNCTION","function",188],["T_WHITESPACE"," ",188],["T_STRING","reduce",188],"(",["T_CALLABLE","callable",188],["T_WHITESPACE"," ",188],["T_VARIABLE","$c",188],",",["T_WHITESPACE"," ",188],["T_VARIABLE","$zero",188],["T_WHITESPACE"," ",188],"=",["T_WHITESPACE"," ",188],["T_STRING","null",188],")",";",["T_WHITESPACE","\n\n    ",188],["T_DOC_COMMENT","\/**\n     * Returns a new collection containing the column or property value found in each\n     * of the elements, as requested in the $matcher param.\n     *\n     * The matcher can be a string with a property name to extract or a dot separated\n     * path of properties that should be followed to get the last one in the path.\n     *\n     * If a column or property could not be found for a particular element in the\n     * collection, that position is filled with null.\n     *\n     * ### Example:\n     *\n     * Extract the user name for all comments in the array:\n     *\n     * ```\n     * $items = [\n     *  ['comment' => ['body' => 'cool', 'user' => ['name' => 'Mark']],\n     *  ['comment' => ['body' => 'very cool', 'user' => ['name' => 'Renan']]\n     * ];\n     * $extracted = (new Collection($items))->extract('comment.user.name');\n     *\n     * \/\/ Result will look like this when converted to array\n     * ['Mark', 'Renan']\n     * ```\n     *\n     * It is also possible to extract a flattened collection out of nested properties\n     *\n     * ```\n     *  $items = [\n     *      ['comment' => ['votes' => [['value' => 1], ['value' => 2], ['value' => 3]]],\n     *      ['comment' => ['votes' => [['value' => 4]]\n     * ];\n     * $extracted = (new Collection($items))->extract('comment.votes.{*}.value');\n     *\n     * \/\/ Result will contain\n     * [1, 2, 3, 4]\n     * ```\n     *\n     * @param string $matcher a dot separated string symbolizing the path to follow\n     * inside the hierarchy of each value so that the column can be extracted.\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",190],["T_WHITESPACE","\n    ",231],["T_PUBLIC","public",232],["T_WHITESPACE"," ",232],["T_FUNCTION","function",232],["T_WHITESPACE"," ",232],["T_STRING","extract",232],"(",["T_VARIABLE","$matcher",232],")",";",["T_WHITESPACE","\n\n    ",232],["T_DOC_COMMENT","\/**\n     * Returns the top element in this collection after being sorted by a property.\n     * Check the sortBy method for information on the callback and $type parameters\n     *\n     * ### Examples:\n     *\n     * ```\n     * \/\/ For a collection of employees\n     * $max = $collection->max('age');\n     * $max = $collection->max('user.salary');\n     * $max = $collection->max(function ($e) {\n     *  return $e->get('user')->get('salary');\n     * });\n     *\n     * \/\/ Display employee name\n     * echo $max->name;\n     * ```\n     *\n     * @param callable|string $callback the callback or column name to use for sorting\n     * @param int $type the type of comparison to perform, either SORT_STRING\n     * SORT_NUMERIC or SORT_NATURAL\n     * @see \\Cake\\Collection\\CollectionIterface::sortBy()\n     * @return mixed The value of the top element in the collection\n     *\/",234],["T_WHITESPACE","\n    ",257],["T_PUBLIC","public",258],["T_WHITESPACE"," ",258],["T_FUNCTION","function",258],["T_WHITESPACE"," ",258],["T_STRING","max",258],"(",["T_VARIABLE","$callback",258],",",["T_WHITESPACE"," ",258],["T_VARIABLE","$type",258],["T_WHITESPACE"," ",258],"=",["T_WHITESPACE"," ",258],["T_STRING","SORT_NUMERIC",258],")",";",["T_WHITESPACE","\n\n    ",258],["T_DOC_COMMENT","\/**\n     * Returns the bottom element in this collection after being sorted by a property.\n     * Check the sortBy method for information on the callback and $type parameters\n     *\n     * ### Examples:\n     *\n     * ```\n     * \/\/ For a collection of employees\n     * $min = $collection->min('age');\n     * $min = $collection->min('user.salary');\n     * $min = $collection->min(function ($e) {\n     *  return $e->get('user')->get('salary');\n     * });\n     *\n     * \/\/ Display employee name\n     * echo $min->name;\n     * ```\n     *\n     * @param callable|string $callback the callback or column name to use for sorting\n     * @param int $type the type of comparison to perform, either SORT_STRING\n     * SORT_NUMERIC or SORT_NATURAL\n     * @see \\Cake\\Collection\\CollectionInterface::sortBy()\n     * @return mixed The value of the bottom element in the collection\n     *\/",260],["T_WHITESPACE","\n    ",283],["T_PUBLIC","public",284],["T_WHITESPACE"," ",284],["T_FUNCTION","function",284],["T_WHITESPACE"," ",284],["T_STRING","min",284],"(",["T_VARIABLE","$callback",284],",",["T_WHITESPACE"," ",284],["T_VARIABLE","$type",284],["T_WHITESPACE"," ",284],"=",["T_WHITESPACE"," ",284],["T_STRING","SORT_NUMERIC",284],")",";",["T_WHITESPACE","\n\n    ",284],["T_DOC_COMMENT","\/**\n     * Returns a sorted iterator out of the elements in this collection,\n     * ranked in ascending order by the results of running each value through a\n     * callback. $callback can also be a string representing the column or property\n     * name.\n     *\n     * The callback will receive as its first argument each of the elements in $items,\n     * the value returned by the callback will be used as the value for sorting such\n     * element. Please note that the callback function could be called more than once\n     * per element.\n     *\n     * ### Example:\n     *\n     * ```\n     * $items = $collection->sortBy(function ($user) {\n     *  return $user->age;\n     * });\n     *\n     * \/\/ alternatively\n     * $items = $collection->sortBy('age');\n     *\n     * \/\/ or use a property path\n     * $items = $collection->sortBy('department.name');\n     *\n     * \/\/ output all user name order by their age in descending order\n     * foreach ($items as $user) {\n     *  echo $user->name;\n     * }\n     * ```\n     *\n     * @param callable|string $callback the callback or column name to use for sorting\n     * @param int $dir either SORT_DESC or SORT_ASC\n     * @param int $type the type of comparison to perform, either SORT_STRING\n     * SORT_NUMERIC or SORT_NATURAL\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",286],["T_WHITESPACE","\n    ",321],["T_PUBLIC","public",322],["T_WHITESPACE"," ",322],["T_FUNCTION","function",322],["T_WHITESPACE"," ",322],["T_STRING","sortBy",322],"(",["T_VARIABLE","$callback",322],",",["T_WHITESPACE"," ",322],["T_VARIABLE","$dir",322],["T_WHITESPACE"," ",322],"=",["T_WHITESPACE"," ",322],["T_STRING","SORT_DESC",322],",",["T_WHITESPACE"," ",322],["T_VARIABLE","$type",322],["T_WHITESPACE"," ",322],"=",["T_WHITESPACE"," ",322],["T_STRING","SORT_NUMERIC",322],")",";",["T_WHITESPACE","\n\n    ",322],["T_DOC_COMMENT","\/**\n     * Splits a collection into sets, grouped by the result of running each value\n     * through the callback. If $callback is a string instead of a callable,\n     * groups by the property named by $callback on each of the values.\n     *\n     * When $callback is a string it should be a property name to extract or\n     * a dot separated path of properties that should be followed to get the last\n     * one in the path.\n     *\n     * ### Example:\n     *\n     * ```\n     * $items = [\n     *  ['id' => 1, 'name' => 'foo', 'parent_id' => 10],\n     *  ['id' => 2, 'name' => 'bar', 'parent_id' => 11],\n     *  ['id' => 3, 'name' => 'baz', 'parent_id' => 10],\n     * ];\n     *\n     * $group = (new Collection($items))->groupBy('parent_id');\n     *\n     * \/\/ Or\n     * $group = (new Collection($items))->groupBy(function ($e) {\n     *  return $e['parent_id'];\n     * });\n     *\n     * \/\/ Result will look like this when converted to array\n     * [\n     *  10 => [\n     *      ['id' => 1, 'name' => 'foo', 'parent_id' => 10],\n     *      ['id' => 3, 'name' => 'baz', 'parent_id' => 10],\n     *  ],\n     *  11 => [\n     *      ['id' => 2, 'name' => 'bar', 'parent_id' => 11],\n     *  ]\n     * ];\n     * ```\n     *\n     * @param callable|string $callback the callback or column name to use for grouping\n     * or a function returning the grouping key out of the provided element\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",324],["T_WHITESPACE","\n    ",364],["T_PUBLIC","public",365],["T_WHITESPACE"," ",365],["T_FUNCTION","function",365],["T_WHITESPACE"," ",365],["T_STRING","groupBy",365],"(",["T_VARIABLE","$callback",365],")",";",["T_WHITESPACE","\n\n    ",365],["T_DOC_COMMENT","\/**\n     * Given a list and a callback function that returns a key for each element\n     * in the list (or a property name), returns an object with an index of each item.\n     * Just like groupBy, but for when you know your keys are unique.\n     *\n     * When $callback is a string it should be a property name to extract or\n     * a dot separated path of properties that should be followed to get the last\n     * one in the path.\n     *\n     * ### Example:\n     *\n     * ```\n     * $items = [\n     *  ['id' => 1, 'name' => 'foo'],\n     *  ['id' => 2, 'name' => 'bar'],\n     *  ['id' => 3, 'name' => 'baz'],\n     * ];\n     *\n     * $indexed = (new Collection($items))->indexBy('id');\n     *\n     * \/\/ Or\n     * $indexed = (new Collection($items))->indexBy(function ($e) {\n     *  return $e['id'];\n     * });\n     *\n     * \/\/ Result will look like this when converted to array\n     * [\n     *  1 => ['id' => 1, 'name' => 'foo'],\n     *  3 => ['id' => 3, 'name' => 'baz'],\n     *  2 => ['id' => 2, 'name' => 'bar'],\n     * ];\n     * ```\n     *\n     * @param callable|string $callback the callback or column name to use for indexing\n     * or a function returning the indexing key out of the provided element\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",367],["T_WHITESPACE","\n    ",403],["T_PUBLIC","public",404],["T_WHITESPACE"," ",404],["T_FUNCTION","function",404],["T_WHITESPACE"," ",404],["T_STRING","indexBy",404],"(",["T_VARIABLE","$callback",404],")",";",["T_WHITESPACE","\n\n    ",404],["T_DOC_COMMENT","\/**\n     * Sorts a list into groups and returns a count for the number of elements\n     * in each group. Similar to groupBy, but instead of returning a list of values,\n     * returns a count for the number of values in that group.\n     *\n     * When $callback is a string it should be a property name to extract or\n     * a dot separated path of properties that should be followed to get the last\n     * one in the path.\n     *\n     * ### Example:\n     *\n     * ```\n     * $items = [\n     *  ['id' => 1, 'name' => 'foo', 'parent_id' => 10],\n     *  ['id' => 2, 'name' => 'bar', 'parent_id' => 11],\n     *  ['id' => 3, 'name' => 'baz', 'parent_id' => 10],\n     * ];\n     *\n     * $group = (new Collection($items))->countBy('parent_id');\n     *\n     * \/\/ Or\n     * $group = (new Collection($items))->countBy(function ($e) {\n     *  return $e['parent_id'];\n     * });\n     *\n     * \/\/ Result will look like this when converted to array\n     * [\n     *  10 => 2,\n     *  11 => 1\n     * ];\n     * ```\n     *\n     * @param callable|string $callback the callback or column name to use for indexing\n     * or a function returning the indexing key out of the provided element\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",406],["T_WHITESPACE","\n    ",441],["T_PUBLIC","public",442],["T_WHITESPACE"," ",442],["T_FUNCTION","function",442],["T_WHITESPACE"," ",442],["T_STRING","countBy",442],"(",["T_VARIABLE","$callback",442],")",";",["T_WHITESPACE","\n\n    ",442],["T_DOC_COMMENT","\/**\n     * Returns the total sum of all the values extracted with $matcher\n     * or of this collection.\n     *\n     * ### Example:\n     *\n     * ```\n     * $items = [\n     *  ['invoice' => ['total' => 100],\n     *  ['invoice' => ['total' => 200]\n     * ];\n     *\n     * $total = (new Collection($items))->sumOf('invoice.total');\n     *\n     * \/\/ Total: 300\n     *\n     * $total = (new Collection([1, 2, 3]))->sumOf();\n     * \/\/ Total: 6\n     * ```\n     *\n     * @param string|callable|null $matcher The property name to sum or a function\n     * If no value is passed, an identity function will be used.\n     * that will return the value of the property to sum.\n     * @return float|int\n     *\/",444],["T_WHITESPACE","\n    ",468],["T_PUBLIC","public",469],["T_WHITESPACE"," ",469],["T_FUNCTION","function",469],["T_WHITESPACE"," ",469],["T_STRING","sumOf",469],"(",["T_VARIABLE","$matcher",469],["T_WHITESPACE"," ",469],"=",["T_WHITESPACE"," ",469],["T_STRING","null",469],")",";",["T_WHITESPACE","\n\n    ",469],["T_DOC_COMMENT","\/**\n     * Returns a new collection with the elements placed in a random order,\n     * this function does not preserve the original keys in the collection.\n     *\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",471],["T_WHITESPACE","\n    ",476],["T_PUBLIC","public",477],["T_WHITESPACE"," ",477],["T_FUNCTION","function",477],["T_WHITESPACE"," ",477],["T_STRING","shuffle",477],"(",")",";",["T_WHITESPACE","\n\n    ",477],["T_DOC_COMMENT","\/**\n     * Returns a new collection with maximum $size random elements\n     * from this collection\n     *\n     * @param int $size the maximum number of elements to randomly\n     * take from this collection\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",479],["T_WHITESPACE","\n    ",486],["T_PUBLIC","public",487],["T_WHITESPACE"," ",487],["T_FUNCTION","function",487],["T_WHITESPACE"," ",487],["T_STRING","sample",487],"(",["T_VARIABLE","$size",487],["T_WHITESPACE"," ",487],"=",["T_WHITESPACE"," ",487],["T_LNUMBER","10",487],")",";",["T_WHITESPACE","\n\n    ",487],["T_DOC_COMMENT","\/**\n     * Returns a new collection with maximum $size elements in the internal\n     * order this collection was created. If a second parameter is passed, it\n     * will determine from what position to start taking elements.\n     *\n     * @param int $size the maximum number of elements to take from\n     * this collection\n     * @param int $from A positional offset from where to take the elements\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",489],["T_WHITESPACE","\n    ",498],["T_PUBLIC","public",499],["T_WHITESPACE"," ",499],["T_FUNCTION","function",499],["T_WHITESPACE"," ",499],["T_STRING","take",499],"(",["T_VARIABLE","$size",499],["T_WHITESPACE"," ",499],"=",["T_WHITESPACE"," ",499],["T_LNUMBER","1",499],",",["T_WHITESPACE"," ",499],["T_VARIABLE","$from",499],["T_WHITESPACE"," ",499],"=",["T_WHITESPACE"," ",499],["T_LNUMBER","0",499],")",";",["T_WHITESPACE","\n\n    ",499],["T_DOC_COMMENT","\/**\n     * Returns a new collection that will skip the specified amount of elements\n     * at the beginning of the iteration.\n     *\n     * @param int $howMany The number of elements to skip.\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",501],["T_WHITESPACE","\n    ",507],["T_PUBLIC","public",508],["T_WHITESPACE"," ",508],["T_FUNCTION","function",508],["T_WHITESPACE"," ",508],["T_STRING","skip",508],"(",["T_VARIABLE","$howMany",508],")",";",["T_WHITESPACE","\n\n    ",508],["T_DOC_COMMENT","\/**\n     * Looks through each value in the list, returning a Collection of all the\n     * values that contain all of the key-value pairs listed in $conditions.\n     *\n     * ### Example:\n     *\n     * ```\n     * $items = [\n     *  ['comment' => ['body' => 'cool', 'user' => ['name' => 'Mark']],\n     *  ['comment' => ['body' => 'very cool', 'user' => ['name' => 'Renan']]\n     * ];\n     *\n     * $extracted = (new Collection($items))->match(['user.name' => 'Renan']);\n     *\n     * \/\/ Result will look like this when converted to array\n     * [\n     *  ['comment' => ['body' => 'very cool', 'user' => ['name' => 'Renan']]\n     * ]\n     * ```\n     *\n     * @param array $conditions a key-value list of conditions where\n     * the key is a property path as accepted by `Collection::extract,\n     * and the value the condition against with each element will be matched\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",510],["T_WHITESPACE","\n    ",534],["T_PUBLIC","public",535],["T_WHITESPACE"," ",535],["T_FUNCTION","function",535],["T_WHITESPACE"," ",535],["T_STRING","match",535],"(",["T_ARRAY","array",535],["T_WHITESPACE"," ",535],["T_VARIABLE","$conditions",535],")",";",["T_WHITESPACE","\n\n    ",535],["T_DOC_COMMENT","\/**\n     * Returns the first result matching all of the key-value pairs listed in\n     * conditions.\n     *\n     * @param array $conditions a key-value list of conditions where the key is\n     * a property path as accepted by `Collection::extract`, and the value the\n     * condition against with each element will be matched\n     * @see \\Cake\\Collection\\CollectionInterface::match()\n     * @return mixed\n     *\/",537],["T_WHITESPACE","\n    ",546],["T_PUBLIC","public",547],["T_WHITESPACE"," ",547],["T_FUNCTION","function",547],["T_WHITESPACE"," ",547],["T_STRING","firstMatch",547],"(",["T_ARRAY","array",547],["T_WHITESPACE"," ",547],["T_VARIABLE","$conditions",547],")",";",["T_WHITESPACE","\n\n    ",547],["T_DOC_COMMENT","\/**\n     * Returns the first result in this collection\n     *\n     * @return mixed The first value in the collection will be returned.\n     *\/",549],["T_WHITESPACE","\n    ",553],["T_PUBLIC","public",554],["T_WHITESPACE"," ",554],["T_FUNCTION","function",554],["T_WHITESPACE"," ",554],["T_STRING","first",554],"(",")",";",["T_WHITESPACE","\n\n    ",554],["T_DOC_COMMENT","\/**\n     * Returns the last result in this collection\n     *\n     * @return mixed The last value in the collection will be returned.\n     *\/",556],["T_WHITESPACE","\n    ",560],["T_PUBLIC","public",561],["T_WHITESPACE"," ",561],["T_FUNCTION","function",561],["T_WHITESPACE"," ",561],["T_STRING","last",561],"(",")",";",["T_WHITESPACE","\n\n    ",561],["T_DOC_COMMENT","\/**\n     * Returns a new collection as the result of concatenating the list of elements\n     * in this collection with the passed list of elements\n     *\n     * @param array|\\Traversable $items Items list.\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",563],["T_WHITESPACE","\n    ",569],["T_PUBLIC","public",570],["T_WHITESPACE"," ",570],["T_FUNCTION","function",570],["T_WHITESPACE"," ",570],["T_STRING","append",570],"(",["T_VARIABLE","$items",570],")",";",["T_WHITESPACE","\n\n    ",570],["T_DOC_COMMENT","\/**\n     * Returns a new collection where the values extracted based on a value path\n     * and then indexed by a key path. Optionally this method can produce parent\n     * groups based on a group property path.\n     *\n     * ### Examples:\n     *\n     * ```\n     * $items = [\n     *  ['id' => 1, 'name' => 'foo', 'parent' => 'a'],\n     *  ['id' => 2, 'name' => 'bar', 'parent' => 'b'],\n     *  ['id' => 3, 'name' => 'baz', 'parent' => 'a'],\n     * ];\n     *\n     * $combined = (new Collection($items))->combine('id', 'name');\n     *\n     * \/\/ Result will look like this when converted to array\n     * [\n     *  1 => 'foo',\n     *  2 => 'bar',\n     *  3 => 'baz',\n     * ];\n     *\n     * $combined = (new Collection($items))->combine('id', 'name', 'parent');\n     *\n     * \/\/ Result will look like this when converted to array\n     * [\n     *  'a' => [1 => 'foo', 3 => 'baz'],\n     *  'b' => [2 => 'bar']\n     * ];\n     * ```\n     *\n     * @param callable|string $keyPath the column name path to use for indexing\n     * or a function returning the indexing key out of the provided element\n     * @param callable|string $valuePath the column name path to use as the array value\n     * or a function returning the value out of the provided element\n     * @param callable|string|null $groupPath the column name path to use as the parent\n     * grouping key or a function returning the key out of the provided element\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",572],["T_WHITESPACE","\n    ",611],["T_PUBLIC","public",612],["T_WHITESPACE"," ",612],["T_FUNCTION","function",612],["T_WHITESPACE"," ",612],["T_STRING","combine",612],"(",["T_VARIABLE","$keyPath",612],",",["T_WHITESPACE"," ",612],["T_VARIABLE","$valuePath",612],",",["T_WHITESPACE"," ",612],["T_VARIABLE","$groupPath",612],["T_WHITESPACE"," ",612],"=",["T_WHITESPACE"," ",612],["T_STRING","null",612],")",";",["T_WHITESPACE","\n\n    ",612],["T_DOC_COMMENT","\/**\n     * Returns a new collection where the values are nested in a tree-like structure\n     * based on an id property path and a parent id property path.\n     *\n     * @param callable|string $idPath the column name path to use for determining\n     * whether an element is parent of another\n     * @param callable|string $parentPath the column name path to use for determining\n     * whether an element is child of another\n     * @param string $nestingKey The key name under which children are nested\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",614],["T_WHITESPACE","\n    ",624],["T_PUBLIC","public",625],["T_WHITESPACE"," ",625],["T_FUNCTION","function",625],["T_WHITESPACE"," ",625],["T_STRING","nest",625],"(",["T_VARIABLE","$idPath",625],",",["T_WHITESPACE"," ",625],["T_VARIABLE","$parentPath",625],",",["T_WHITESPACE"," ",625],["T_VARIABLE","$nestingKey",625],["T_WHITESPACE"," ",625],"=",["T_WHITESPACE"," ",625],["T_CONSTANT_ENCAPSED_STRING","'children'",625],")",";",["T_WHITESPACE","\n\n    ",625],["T_DOC_COMMENT","\/**\n     * Returns a new collection containing each of the elements found in `$values` as\n     * a property inside the corresponding elements in this collection. The property\n     * where the values will be inserted is described by the `$path` parameter.\n     *\n     * The $path can be a string with a property name or a dot separated path of\n     * properties that should be followed to get the last one in the path.\n     *\n     * If a column or property could not be found for a particular element in the\n     * collection as part of the path, the element will be kept unchanged.\n     *\n     * ### Example:\n     *\n     * Insert ages into a collection containing users:\n     *\n     * ```\n     * $items = [\n     *  ['comment' => ['body' => 'cool', 'user' => ['name' => 'Mark']],\n     *  ['comment' => ['body' => 'awesome', 'user' => ['name' => 'Renan']]\n     * ];\n     * $ages = [25, 28];\n     * $inserted = (new Collection($items))->insert('comment.user.age', $ages);\n     *\n     * \/\/ Result will look like this when converted to array\n     * [\n     *  ['comment' => ['body' => 'cool', 'user' => ['name' => 'Mark', 'age' => 25]],\n     *  ['comment' => ['body' => 'awesome', 'user' => ['name' => 'Renan', 'age' => 28]]\n     * ];\n     * ```\n     *\n     * @param string $path a dot separated string symbolizing the path to follow\n     * inside the hierarchy of each value so that the value can be inserted\n     * @param mixed $values The values to be inserted at the specified path,\n     * values are matched with the elements in this collection by its positional index.\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",627],["T_WHITESPACE","\n    ",662],["T_PUBLIC","public",663],["T_WHITESPACE"," ",663],["T_FUNCTION","function",663],["T_WHITESPACE"," ",663],["T_STRING","insert",663],"(",["T_VARIABLE","$path",663],",",["T_WHITESPACE"," ",663],["T_VARIABLE","$values",663],")",";",["T_WHITESPACE","\n\n    ",663],["T_DOC_COMMENT","\/**\n     * Returns an array representation of the results\n     *\n     * @param bool $preserveKeys whether to use the keys returned by this\n     * collection as the array keys. Keep in mind that it is valid for iterators\n     * to return the same key for different elements, setting this value to false\n     * can help getting all items if keys are not important in the result.\n     * @return array\n     *\/",665],["T_WHITESPACE","\n    ",673],["T_PUBLIC","public",674],["T_WHITESPACE"," ",674],["T_FUNCTION","function",674],["T_WHITESPACE"," ",674],["T_STRING","toArray",674],"(",["T_VARIABLE","$preserveKeys",674],["T_WHITESPACE"," ",674],"=",["T_WHITESPACE"," ",674],["T_STRING","true",674],")",";",["T_WHITESPACE","\n\n    ",674],["T_DOC_COMMENT","\/**\n     * Returns an numerically-indexed array representation of the results.\n     * This is equivalent to calling `toArray(false)`\n     *\n     * @return array\n     *\/",676],["T_WHITESPACE","\n    ",681],["T_PUBLIC","public",682],["T_WHITESPACE"," ",682],["T_FUNCTION","function",682],["T_WHITESPACE"," ",682],["T_STRING","toList",682],"(",")",";",["T_WHITESPACE","\n\n    ",682],["T_DOC_COMMENT","\/**\n     * Convert a result set into JSON.\n     *\n     * Part of JsonSerializable interface.\n     *\n     * @return array The data to convert to JSON\n     *\/",684],["T_WHITESPACE","\n    ",690],["T_PUBLIC","public",691],["T_WHITESPACE"," ",691],["T_FUNCTION","function",691],["T_WHITESPACE"," ",691],["T_STRING","jsonSerialize",691],"(",")",";",["T_WHITESPACE","\n\n    ",691],["T_DOC_COMMENT","\/**\n     * Iterates once all elements in this collection and executes all stacked\n     * operations of them, finally it returns a new collection with the result.\n     * This is useful for converting non-rewindable internal iterators into\n     * a collection that can be rewound and used multiple times.\n     *\n     * A common use case is to re-use the same variable for calculating different\n     * data. In those cases it may be helpful and more performant to first compile\n     * a collection and then apply more operations to it.\n     *\n     * ### Example:\n     *\n     * ```\n     * $collection->map($mapper)->sortBy('age')->extract('name');\n     * $compiled = $collection->compile();\n     * $isJohnHere = $compiled->some($johnMatcher);\n     * $allButJohn = $compiled->filter($johnMatcher);\n     * ```\n     *\n     * In the above example, had the collection not been compiled before, the\n     * iterations for `map`, `sortBy` and `extract` would've been executed twice:\n     * once for getting `$isJohnHere` and once for `$allButJohn`\n     *\n     * You can think of this method as a way to create save points for complex\n     * calculations in a collection.\n     *\n     * @param bool $preserveKeys whether to use the keys returned by this\n     * collection as the array keys. Keep in mind that it is valid for iterators\n     * to return the same key for different elements, setting this value to false\n     * can help getting all items if keys are not important in the result.\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",693],["T_WHITESPACE","\n    ",724],["T_PUBLIC","public",725],["T_WHITESPACE"," ",725],["T_FUNCTION","function",725],["T_WHITESPACE"," ",725],["T_STRING","compile",725],"(",["T_VARIABLE","$preserveKeys",725],["T_WHITESPACE"," ",725],"=",["T_WHITESPACE"," ",725],["T_STRING","true",725],")",";",["T_WHITESPACE","\n\n    ",725],["T_DOC_COMMENT","\/**\n     * Returns a new collection where the operations performed by this collection.\n     * No matter how many times the new collection is iterated, those operations will\n     * only be performed once.\n     *\n     * This can also be used to make any non-rewindable iterator rewindable.\n     *\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",727],["T_WHITESPACE","\n    ",735],["T_PUBLIC","public",736],["T_WHITESPACE"," ",736],["T_FUNCTION","function",736],["T_WHITESPACE"," ",736],["T_STRING","buffered",736],"(",")",";",["T_WHITESPACE","\n\n    ",736],["T_DOC_COMMENT","\/**\n     * Returns a new collection with each of the elements of this collection\n     * after flattening the tree structure. The tree structure is defined\n     * by nesting elements under a key with a known name. It is possible\n     * to specify such name by using the '$nestingKey' parameter.\n     *\n     * By default all elements in the tree following a Depth First Search\n     * will be returned, that is, elements from the top parent to the leaves\n     * for each branch.\n     *\n     * It is possible to return all elements from bottom to top using a Breadth First\n     * Search approach by passing the '$dir' parameter with 'asc'. That is, it will\n     * return all elements for the same tree depth first and from bottom to top.\n     *\n     * Finally, you can specify to only get a collection with the leaf nodes in the\n     * tree structure. You do so by passing 'leaves' in the first argument.\n     *\n     * The possible values for the first argument are aliases for the following\n     * constants and it is valid to pass those instead of the alias:\n     *\n     * - desc: TreeIterator::SELF_FIRST\n     * - asc: TreeIterator::CHILD_FIRST\n     * - leaves: TreeIterator::LEAVES_ONLY\n     *\n     * ### Example:\n     *\n     * ```\n     * $collection = new Collection([\n     *  ['id' => 1, 'children' => [['id' => 2, 'children' => [['id' => 3]]]]],\n     *  ['id' => 4, 'children' => [['id' => 5]]]\n     * ]);\n     * $flattenedIds = $collection->listNested()->extract('id'); \/\/ Yields [1, 2, 3, 4, 5]\n     * ```\n     *\n     * @param string|int $dir The direction in which to return the elements\n     * @param string|callable $nestingKey The key name under which children are nested\n     * or a callable function that will return the children list\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",738],["T_WHITESPACE","\n    ",776],["T_PUBLIC","public",777],["T_WHITESPACE"," ",777],["T_FUNCTION","function",777],["T_WHITESPACE"," ",777],["T_STRING","listNested",777],"(",["T_VARIABLE","$dir",777],["T_WHITESPACE"," ",777],"=",["T_WHITESPACE"," ",777],["T_CONSTANT_ENCAPSED_STRING","'desc'",777],",",["T_WHITESPACE"," ",777],["T_VARIABLE","$nestingKey",777],["T_WHITESPACE"," ",777],"=",["T_WHITESPACE"," ",777],["T_CONSTANT_ENCAPSED_STRING","'children'",777],")",";",["T_WHITESPACE","\n\n    ",777],["T_DOC_COMMENT","\/**\n     * Creates a new collection that when iterated will stop yielding results if\n     * the provided condition evaluates to false.\n     *\n     * This is handy for dealing with infinite iterators or any generator that\n     * could start returning invalid elements at a certain point. For example,\n     * when reading lines from a file stream you may want to stop the iteration\n     * after a certain value is reached.\n     *\n     * ### Example:\n     *\n     * Get an array of lines in a CSV file until the timestamp column is less than a date\n     *\n     * ```\n     * $lines = (new Collection($fileLines))->stopWhen(function ($value, $key) {\n     *  return (new DateTime($value))->format('Y') < 2012;\n     * })\n     * ->toArray();\n     * ```\n     *\n     * Get elements until the first unapproved message is found:\n     *\n     * ```\n     * $comments = (new Collection($comments))->stopWhen(['is_approved' => false]);\n     * ```\n     *\n     * @param callable $condition the method that will receive each of the elements and\n     * returns false when the iteration should be stopped.\n     * If an array, it will be interpreted as a key-value list of conditions where\n     * the key is a property path as accepted by `Collection::extract`,\n     * and the value the condition against with each element will be matched.\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",779],["T_WHITESPACE","\n    ",811],["T_PUBLIC","public",812],["T_WHITESPACE"," ",812],["T_FUNCTION","function",812],["T_WHITESPACE"," ",812],["T_STRING","stopWhen",812],"(",["T_VARIABLE","$condition",812],")",";",["T_WHITESPACE","\n\n    ",812],["T_DOC_COMMENT","\/**\n     * Creates a new collection where the items are the\n     * concatenation of the lists of items generated by the transformer function\n     * applied to each item in the original collection.\n     *\n     * The transformer function will receive the value and the key for each of the\n     * items in the collection, in that order, and it must return an array or a\n     * Traversable object that can be concatenated to the final result.\n     *\n     * If no transformer function is passed, an \"identity\" function will be used.\n     * This is useful when each of the elements in the source collection are\n     * lists of items to be appended one after another.\n     *\n     * ### Example:\n     *\n     * ```\n     * $items [[1, 2, 3], [4, 5]];\n     * $unfold = (new Collection($items))->unfold(); \/\/ Returns [1, 2, 3, 4, 5]\n     * ```\n     *\n     * Using a transformer\n     *\n     * ```\n     * $items [1, 2, 3];\n     * $allItems = (new Collection($items))->unfold(function ($page) {\n     *  return $service->fetchPage($page)->toArray();\n     * });\n     * ```\n     *\n     * @param callable|null $transformer A callable function that will receive each of\n     * the items in the collection and should return an array or Traversable object\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",814],["T_WHITESPACE","\n    ",846],["T_PUBLIC","public",847],["T_WHITESPACE"," ",847],["T_FUNCTION","function",847],["T_WHITESPACE"," ",847],["T_STRING","unfold",847],"(",["T_CALLABLE","callable",847],["T_WHITESPACE"," ",847],["T_VARIABLE","$transformer",847],["T_WHITESPACE"," ",847],"=",["T_WHITESPACE"," ",847],["T_STRING","null",847],")",";",["T_WHITESPACE","\n\n    ",847],["T_DOC_COMMENT","\/**\n     * Passes this collection through a callable as its first argument.\n     * This is useful for decorating the full collection with another object.\n     *\n     * ### Example:\n     *\n     * ```\n     * $items = [1, 2, 3];\n     * $decorated = (new Collection($items))->through(function ($collection) {\n     *      return new MyCustomCollection($collection);\n     * });\n     * ```\n     *\n     * @param callable $handler A callable function that will receive\n     * this collection as first argument.\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",849],["T_WHITESPACE","\n    ",865],["T_PUBLIC","public",866],["T_WHITESPACE"," ",866],["T_FUNCTION","function",866],["T_WHITESPACE"," ",866],["T_STRING","through",866],"(",["T_CALLABLE","callable",866],["T_WHITESPACE"," ",866],["T_VARIABLE","$handler",866],")",";",["T_WHITESPACE","\n\n    ",866],["T_DOC_COMMENT","\/**\n     * Combines the elements of this collection with each of the elements of the\n     * passed iterables, using their positional index as a reference.\n     *\n     * ### Example:\n     *\n     * ```\n     * $collection = new Collection([1, 2]);\n     * $collection->zip([3, 4], [5, 6])->toList(); \/\/ returns [[1, 3, 5], [2, 4, 6]]\n     * ```\n     *\n     * @param array|\\Traversable ...$items The collections to zip.\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",868],["T_WHITESPACE","\n    ",881],["T_PUBLIC","public",882],["T_WHITESPACE"," ",882],["T_FUNCTION","function",882],["T_WHITESPACE"," ",882],["T_STRING","zip",882],"(",["T_VARIABLE","$items",882],")",";",["T_WHITESPACE","\n\n    ",882],["T_DOC_COMMENT","\/**\n     * Combines the elements of this collection with each of the elements of the\n     * passed iterables, using their positional index as a reference.\n     *\n     * The resulting element will be the return value of the $callable function.\n     *\n     * ### Example:\n     *\n     * ```\n     * $collection = new Collection([1, 2]);\n     * $zipped = $collection->zipWith([3, 4], [5, 6], function () {\n     *   return array_sum(func_get_args());\n     * });\n     * $zipped->toList(); \/\/ returns [9, 12]; [(1 + 3 + 5), (2 + 4 + 6)]\n     * ```\n     *\n     * @param array|\\Traversable ...$items The collections to zip.\n     * @param callable $callable The function to use for zipping the elements together.\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",884],["T_WHITESPACE","\n    ",903],["T_PUBLIC","public",904],["T_WHITESPACE"," ",904],["T_FUNCTION","function",904],["T_WHITESPACE"," ",904],["T_STRING","zipWith",904],"(",["T_VARIABLE","$items",904],",",["T_WHITESPACE"," ",904],["T_VARIABLE","$callable",904],")",";",["T_WHITESPACE","\n\n    ",904],["T_DOC_COMMENT","\/**\n     * Breaks the collection into smaller arrays of the given size.\n     *\n     * ### Example:\n     *\n     * ```\n     * $items [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n     * $chunked = (new Collection($items))->chunk(3)->toList();\n     * \/\/ Returns [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11]]\n     * ```\n     *\n     * @param int $chunkSize The maximum size for each chunk\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",906],["T_WHITESPACE","\n    ",919],["T_PUBLIC","public",920],["T_WHITESPACE"," ",920],["T_FUNCTION","function",920],["T_WHITESPACE"," ",920],["T_STRING","chunk",920],"(",["T_VARIABLE","$chunkSize",920],")",";",["T_WHITESPACE","\n\n    ",920],["T_DOC_COMMENT","\/**\n     * Returns whether or not there are elements in this collection\n     *\n     * ### Example:\n     *\n     * ```\n     * $items [1, 2, 3];\n     * (new Collection($items))->isEmpty(); \/\/ false\n     * ```\n     *\n     * ```\n     * (new Collection([]))->isEmpty(); \/\/ true\n     * ```\n     *\n     * @return bool\n     *\/",922],["T_WHITESPACE","\n    ",937],["T_PUBLIC","public",938],["T_WHITESPACE"," ",938],["T_FUNCTION","function",938],["T_WHITESPACE"," ",938],["T_STRING","isEmpty",938],"(",")",";",["T_WHITESPACE","\n\n    ",938],["T_DOC_COMMENT","\/**\n     * Returns the closest nested iterator that can be safely traversed without\n     * losing any possible transformations. This is used mainly to remove empty\n     * IteratorIterator wrappers that can only slowdown the iteration process.\n     *\n     * @return \\Iterator\n     *\/",940],["T_WHITESPACE","\n    ",946],["T_PUBLIC","public",947],["T_WHITESPACE"," ",947],["T_FUNCTION","function",947],["T_WHITESPACE"," ",947],["T_STRING","unwrap",947],"(",")",";",["T_WHITESPACE","\n\n    ",947],["T_DOC_COMMENT","\/**\n     * Transpose rows and columns into columns and rows\n     *\n     * ### Example:\n     *\n     * ```\n     * $items = [\n     *       ['Products', '2012', '2013', '2014'],\n     *       ['Product A', '200', '100', '50'],\n     *       ['Product B', '300', '200', '100'],\n     *       ['Product C', '400', '300', '200'],\n     * ]\n     *\n     * $transpose = (new Collection($items))->transpose()->toList();\n     *\n     * \/\/ Returns\n     * \/\/ [\n     * \/\/     ['Products', 'Product A', 'Product B', 'Product C'],\n     * \/\/     ['2012', '200', '300', '400'],\n     * \/\/     ['2013', '100', '200', '300'],\n     * \/\/     ['2014', '50', '100', '200'],\n     * \/\/ ]\n     * ```\n     *\n     * @return \\Cake\\Collection\\CollectionInterface\n     *\/",949],["T_WHITESPACE","\n    ",974],["T_PUBLIC","public",975],["T_WHITESPACE"," ",975],["T_FUNCTION","function",975],["T_WHITESPACE"," ",975],["T_STRING","transpose",975],"(",")",";",["T_WHITESPACE","\n",975],"}",["T_WHITESPACE","\n",976]]