[["T_OPEN_TAG","<?php\n",1],["T_WHITESPACE","\n",2],["T_COMMENT","\/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n *\/",3],["T_WHITESPACE","\n\n",10],["T_NAMESPACE","namespace",12],["T_WHITESPACE"," ",12],["T_STRING","Symfony",12],["T_NS_SEPARATOR","\\",12],["T_STRING","Component",12],["T_NS_SEPARATOR","\\",12],["T_STRING","HttpKernel",12],["T_NS_SEPARATOR","\\",12],["T_STRING","EventListener",12],";",["T_WHITESPACE","\n\n",12],["T_USE","use",14],["T_WHITESPACE"," ",14],["T_STRING","Symfony",14],["T_NS_SEPARATOR","\\",14],["T_STRING","Component",14],["T_NS_SEPARATOR","\\",14],["T_STRING","EventDispatcher",14],["T_NS_SEPARATOR","\\",14],["T_STRING","EventSubscriberInterface",14],";",["T_WHITESPACE","\n",14],["T_USE","use",15],["T_WHITESPACE"," ",15],["T_STRING","Symfony",15],["T_NS_SEPARATOR","\\",15],["T_STRING","Component",15],["T_NS_SEPARATOR","\\",15],["T_STRING","HttpKernel",15],["T_NS_SEPARATOR","\\",15],["T_STRING","Event",15],["T_NS_SEPARATOR","\\",15],["T_STRING","FilterResponseEvent",15],";",["T_WHITESPACE","\n",15],["T_USE","use",16],["T_WHITESPACE"," ",16],["T_STRING","Symfony",16],["T_NS_SEPARATOR","\\",16],["T_STRING","Component",16],["T_NS_SEPARATOR","\\",16],["T_STRING","HttpKernel",16],["T_NS_SEPARATOR","\\",16],["T_STRING","KernelEvents",16],";",["T_WHITESPACE","\n\n",16],["T_DOC_COMMENT","\/**\n * Saves the session, in case it is still open, before sending the response\/headers.\n *\n * This ensures several things in case the developer did not save the session explicitly:\n *\n *  * If a session save handler without locking is used, it ensures the data is available\n *    on the next request, e.g. after a redirect. PHPs auto-save at script end via\n *    session_register_shutdown is executed after fastcgi_finish_request. So in this case\n *    the data could be missing the next request because it might not be saved the moment\n *    the new request is processed.\n *  * A locking save handler (e.g. the native 'files') circumvents concurrency problems like\n *    the one above. But by saving the session before long-running things in the terminate event,\n *    we ensure the session is not blocked longer than needed.\n *  * When regenerating the session ID no locking is involved in PHPs session design. See\n *    https:\/\/bugs.php.net\/bug.php?id=61470 for a discussion. So in this case, the session must\n *    be saved anyway before sending the headers with the new session ID. Otherwise session\n *    data could get lost again for concurrent requests with the new ID. One result could be\n *    that you get logged out after just logging in.\n *\n * This listener should be executed as one of the last listeners, so that previous listeners\n * can still operate on the open session. This prevents the overhead of restarting it.\n * Listeners after closing the session can still work with the session as usual because\n * Symfonys session implementation starts the session on demand. So writing to it after\n * it is saved will just restart it.\n *\n * @author Tobias Schultze <http:\/\/tobion.de>\n *\/",18],["T_WHITESPACE","\n",44],["T_CLASS","class",45],["T_WHITESPACE"," ",45],["T_STRING","SaveSessionListener",45],["T_WHITESPACE"," ",45],["T_IMPLEMENTS","implements",45],["T_WHITESPACE"," ",45],["T_STRING","EventSubscriberInterface",45],["T_WHITESPACE","\n",45],"{",["T_WHITESPACE","\n    ",46],["T_PUBLIC","public",47],["T_WHITESPACE"," ",47],["T_FUNCTION","function",47],["T_WHITESPACE"," ",47],["T_STRING","onKernelResponse",47],"(",["T_STRING","FilterResponseEvent",47],["T_WHITESPACE"," ",47],["T_VARIABLE","$event",47],")",["T_WHITESPACE","\n    ",47],"{",["T_WHITESPACE","\n        ",48],["T_IF","if",49],["T_WHITESPACE"," ",49],"(","!",["T_VARIABLE","$event",49],["T_OBJECT_OPERATOR","->",49],["T_STRING","isMasterRequest",49],"(",")",")",["T_WHITESPACE"," ",49],"{",["T_WHITESPACE","\n            ",49],["T_RETURN","return",50],";",["T_WHITESPACE","\n        ",50],"}",["T_WHITESPACE","\n\n        ",51],["T_VARIABLE","$session",53],["T_WHITESPACE"," ",53],"=",["T_WHITESPACE"," ",53],["T_VARIABLE","$event",53],["T_OBJECT_OPERATOR","->",53],["T_STRING","getRequest",53],"(",")",["T_OBJECT_OPERATOR","->",53],["T_STRING","getSession",53],"(",")",";",["T_WHITESPACE","\n        ",53],["T_IF","if",54],["T_WHITESPACE"," ",54],"(",["T_VARIABLE","$session",54],["T_WHITESPACE"," ",54],["T_BOOLEAN_AND","&&",54],["T_WHITESPACE"," ",54],["T_VARIABLE","$session",54],["T_OBJECT_OPERATOR","->",54],["T_STRING","isStarted",54],"(",")",")",["T_WHITESPACE"," ",54],"{",["T_WHITESPACE","\n            ",54],["T_VARIABLE","$session",55],["T_OBJECT_OPERATOR","->",55],["T_STRING","save",55],"(",")",";",["T_WHITESPACE","\n        ",55],"}",["T_WHITESPACE","\n    ",56],"}",["T_WHITESPACE","\n\n    ",57],["T_PUBLIC","public",59],["T_WHITESPACE"," ",59],["T_STATIC","static",59],["T_WHITESPACE"," ",59],["T_FUNCTION","function",59],["T_WHITESPACE"," ",59],["T_STRING","getSubscribedEvents",59],"(",")",["T_WHITESPACE","\n    ",59],"{",["T_WHITESPACE","\n        ",60],["T_RETURN","return",61],["T_WHITESPACE"," ",61],["T_ARRAY","array",61],"(",["T_WHITESPACE","\n            ",61],["T_COMMENT","\/\/ low priority but higher than StreamedResponseListener\n",62],["T_WHITESPACE","            ",63],["T_STRING","KernelEvents",63],["T_DOUBLE_COLON","::",63],["T_STRING","RESPONSE",63],["T_WHITESPACE"," ",63],["T_DOUBLE_ARROW","=>",63],["T_WHITESPACE"," ",63],["T_ARRAY","array",63],"(",["T_ARRAY","array",63],"(",["T_CONSTANT_ENCAPSED_STRING","'onKernelResponse'",63],",",["T_WHITESPACE"," ",63],"-",["T_LNUMBER","1000",63],")",")",",",["T_WHITESPACE","\n        ",63],")",";",["T_WHITESPACE","\n    ",64],"}",["T_WHITESPACE","\n",65],"}",["T_WHITESPACE","\n",66]]