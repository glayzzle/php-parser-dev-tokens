[["T_OPEN_TAG","<?php\n",1],["T_WHITESPACE","\n",2],["T_NAMESPACE","namespace",3],["T_WHITESPACE"," ",3],["T_STRING","Drupal",3],["T_NS_SEPARATOR","\\",3],["T_STRING","Core",3],["T_NS_SEPARATOR","\\",3],["T_STRING","Render",3],";",["T_WHITESPACE","\n\n",3],["T_DOC_COMMENT","\/**\n * Defines an interface for turning a render array into a string.\n *\/",5],["T_WHITESPACE","\n",7],["T_INTERFACE","interface",8],["T_WHITESPACE"," ",8],["T_STRING","RendererInterface",8],["T_WHITESPACE"," ",8],"{",["T_WHITESPACE","\n\n  ",8],["T_DOC_COMMENT","\/**\n   * Renders final HTML given a structured array tree.\n   *\n   * Calls ::render() in such a way that placeholders are replaced.\n   *\n   * Should therefore only be used in occasions where the final rendering is\n   * happening, just before sending a Response:\n   * - system internals that are responsible for rendering the final HTML\n   * - render arrays for non-HTML responses, such as feeds\n   *\n   * (Cannot be executed within another render context.)\n   *\n   * @param array $elements\n   *   The structured array describing the data to be rendered.\n   *\n   * @return \\Drupal\\Component\\Render\\MarkupInterface\n   *   The rendered HTML.\n   *\n   * @throws \\LogicException\n   *   When called from inside another renderRoot() call.\n   *\n   * @see \\Drupal\\Core\\Render\\RendererInterface::render()\n   *\/",10],["T_WHITESPACE","\n  ",32],["T_PUBLIC","public",33],["T_WHITESPACE"," ",33],["T_FUNCTION","function",33],["T_WHITESPACE"," ",33],["T_STRING","renderRoot",33],"(","&",["T_VARIABLE","$elements",33],")",";",["T_WHITESPACE","\n\n  ",33],["T_DOC_COMMENT","\/**\n   * Renders final HTML in situations where no assets are needed.\n   *\n   * Calls ::render() in such a way that placeholders are replaced.\n   *\n   * Useful for instance when rendering the values of tokens or emails, which\n   * need a render array being turned into a string, but do not need any of the\n   * bubbleable metadata (the attached assets and cache tags).\n   *\n   * Some of these are a relatively common use case and happen *within* a\n   * ::renderRoot() call, but that is generally highly problematic (and hence an\n   * exception is thrown when a ::renderRoot() call happens within another\n   * ::renderRoot() call). However, in this case, we only care about the output,\n   * not about the bubbling. Hence this uses a separate render context, to not\n   * affect the parent ::renderRoot() call.\n   *\n   * (Can be executed within another render context: it runs in isolation.)\n   *\n   * @param array $elements\n   *   The structured array describing the data to be rendered.\n   *\n   * @return \\Drupal\\Component\\Render\\MarkupInterface\n   *   The rendered HTML.\n   *\n   * @see \\Drupal\\Core\\Render\\RendererInterface::renderRoot()\n   * @see \\Drupal\\Core\\Render\\RendererInterface::render()\n   *\/",35],["T_WHITESPACE","\n  ",61],["T_PUBLIC","public",62],["T_WHITESPACE"," ",62],["T_FUNCTION","function",62],["T_WHITESPACE"," ",62],["T_STRING","renderPlain",62],"(","&",["T_VARIABLE","$elements",62],")",";",["T_WHITESPACE","\n\n  ",62],["T_DOC_COMMENT","\/**\n   * Renders final HTML for a placeholder.\n   *\n   * Renders the placeholder in isolation.\n   *\n   * @param string $placeholder\n   *   An attached placeholder to render. (This must be a key of one of the\n   *   values of $elements['#attached']['placeholders'].)\n   * @param array $elements\n   *   The structured array describing the data to be rendered.\n   *\n   * @return array\n   *   The updated $elements.\n   *\n   * @see \\Drupal\\Core\\Render\\RendererInterface::render()\n   *\/",64],["T_WHITESPACE","\n  ",79],["T_PUBLIC","public",80],["T_WHITESPACE"," ",80],["T_FUNCTION","function",80],["T_WHITESPACE"," ",80],["T_STRING","renderPlaceholder",80],"(",["T_VARIABLE","$placeholder",80],",",["T_WHITESPACE"," ",80],["T_ARRAY","array",80],["T_WHITESPACE"," ",80],["T_VARIABLE","$elements",80],")",";",["T_WHITESPACE","\n\n  ",80],["T_DOC_COMMENT","\/**\n   * Renders HTML given a structured array tree.\n   *\n   * Renderable arrays have two kinds of key\/value pairs: properties and\n   * children. Properties have keys starting with '#' and their values influence\n   * how the array will be rendered. Children are all elements whose keys do not\n   * start with a '#'. Their values should be renderable arrays themselves,\n   * which will be rendered during the rendering of the parent array. The markup\n   * provided by the children is typically inserted into the markup generated by\n   * the parent array.\n   *\n   * An important aspect of rendering is caching the result, when appropriate.\n   * Because the HTML of a rendered item includes all of the HTML of the\n   * rendered children, caching it requires certain information to bubble up\n   * from child elements to their parents:\n   * - Cache contexts, so that the render cache is varied by every context that\n   *   affects the rendered HTML. Because cache contexts affect the cache ID,\n   *   and therefore must be resolved for cache hits as well as misses, it is\n   *   up to the implementation of this interface to decide how to implement\n   *   the caching of items whose children specify cache contexts not directly\n   *   specified by the parent. \\Drupal\\Core\\Render\\Renderer implements this\n   *   with a lazy two-tier caching strategy. Alternate strategies could be to\n   *   not cache such parents at all or to cache them with the child elements\n   *   replaced by placeholder tokens that are dynamically rendered after cache\n   *   retrieval.\n   * - Cache tags, so that cached renderings are invalidated when site content\n   *   or configuration that can affect that rendering changes.\n   * - Placeholders, with associated self-contained placeholder render arrays,\n   *   for executing code to handle dynamic requirements that cannot be cached.\n   * A render context (\\Drupal\\Core\\Render\\RenderContext) can be used to perform\n   * bubbling; it is a stack of \\Drupal\\Core\\Render\\BubbleableMetadata objects.\n   *\n   * Additionally, whether retrieving from cache or not, it is important to\n   * know all of the assets (CSS and JavaScript) required by the rendered HTML,\n   * and this must also bubble from child to parent. Therefore,\n   * \\Drupal\\Core\\Render\\BubbleableMetadata includes that data as well.\n   *\n   * The process of rendering an element is recursive unless the element defines\n   * an implemented theme hook in #theme. During each call to\n   * Renderer::render(), the outermost renderable array (also known as an\n   * \"element\") is processed using the following steps:\n   *   - If this element has already been printed (#printed = TRUE) or the user\n   *     does not have access to it (#access = FALSE), then an empty string is\n   *     returned.\n   *   - If no render context is set yet, an exception is thrown. Otherwise,\n   *     an empty \\Drupal\\Core\\Render\\BubbleableMetadata is pushed onto the\n   *     render context.\n   *   - If this element has #cache defined then the cached markup for this\n   *     element will be returned if it exists in Renderer::render()'s cache. To\n   *     use Renderer::render() caching, set the element's #cache property to an\n   *     associative array with one or several of the following keys:\n   *     - 'keys': An array of one or more keys that identify the element. If\n   *       'keys' is set, the cache ID is created automatically from these keys.\n   *     - 'contexts': An array of one or more cache context IDs. These are\n   *       converted to a final value depending on the request. (For instance,\n   *       'user' is mapped to the current user's ID.)\n   *     - 'max-age': A time in seconds. Zero seconds means it is not cacheable.\n   *       \\Drupal\\Core\\Cache\\Cache::PERMANENT means it is cacheable forever.\n   *     - 'bin': Specify a cache bin to cache the element in. Default is\n   *       'default'.\n   *     When there is a render cache hit, there is no rendering work left to be\n   *     done, so the stack must be updated. The empty (and topmost) frame that\n   *     was just pushed onto the stack is updated with all bubbleable rendering\n   *     metadata from the element retrieved from render cache. Then, this stack\n   *     frame is bubbled: the two topmost frames are popped from the stack,\n   *     they are merged, and the result is pushed back onto the stack.\n   *     However, also in case of a cache miss we have to do something. Note\n   *     that a Renderer renders top-down, which means that we try to render a\n   *     parent first, and we try to avoid the work of rendering the children by\n   *     using the render cache. Though in this case, we are dealing with a\n   *     cache miss. So a Renderer traverses down the tree, rendering all\n   *     children. In doing so, the render stack is updated with the bubbleable\n   *     metadata of the children. That means that once the children are\n   *     rendered, we can render cache this element. But the cache ID may have\n   *     *changed* at that point, because the children's cache contexts have\n   *     been bubbled!\n   *     It is for that case that we must store the current (pre-bubbling) cache\n   *     ID, so that we can compare it with the new (post-bubbling) cache ID\n   *     when writing to the cache. We store the current cache ID in\n   *     $pre_bubbling_cid.\n   *   - If this element has #type defined and the default attributes for this\n   *     element have not already been merged in (#defaults_loaded = TRUE) then\n   *     the defaults for this type of element, defined by an element plugin,\n   *     are merged into the array. #defaults_loaded is set by functions that\n   *     process render arrays and call the element info service before passing\n   *     the array to Renderer::render(), such as form_builder() in the Form\n   *     API.\n   *   - If this element has #create_placeholder set to TRUE, and it has a\n   *     #lazy_builder callback, then the element is replaced with another\n   *     element that has only two properties: #markup and #attached. #markup\n   *     will contain placeholder markup, and #attached contains the placeholder\n   *     metadata, that will be used for replacing this placeholder. That\n   *     metadata contains a very compact render array (containing only\n   *     #lazy_builder and #cache) that will be rendered to replace the\n   *     placeholder with its final markup. This means that when the\n   *     #lazy_builder callback is called, it received a render array to add to\n   *     that only contains #cache.\n   *   - If this element has a #lazy_builder or an array of #pre_render\n   *     functions defined, they are called sequentially to modify the element\n   *     before rendering. #lazy_builder is preferred, since it allows for\n   *     placeholdering (see previous step), but #pre_render is still supported.\n   *     Both have their use case: #lazy_builder is for building a render array,\n   *     #pre_render is for decorating an existing render array.\n   *     After the #lazy_builder function is called, #lazy_builder is removed,\n   *     and #built is set to TRUE.\n   *     After the #lazy_builder and all #pre_render functions have been called,\n   *     #printed is checked a second time in case a #lazy_builder or\n   *     #pre_render function flags the element as printed. If #printed is set,\n   *     we return early and hence no rendering work is left to be done,\n   *     similarly to a render cache hit. Once again, the empty (and topmost)\n   *     frame that was just pushed onto the stack is updated with all\n   *     bubbleable rendering metadata from the element whose #printed = TRUE.\n   *     Then, this stack frame is bubbled: the two topmost frames are popped\n   *     from the stack, they are merged, and the result is pushed back onto the\n   *     stack.\n   *   - The child elements of this element are sorted by weight using uasort()\n   *     in \\Drupal\\Core\\Render\\Element::children(). Since this is expensive,\n   *     when passing already sorted elements to Renderer::render(), for example\n   *     from a database query, set $elements['#sorted'] = TRUE to avoid sorting\n   *     them a second time.\n   *   - The main render phase to produce #children for this element takes\n   *     place:\n   *     - If this element has #theme defined and #theme is an implemented theme\n   *       hook\/suggestion then ThemeManagerInterface::render() is called and\n   *       must render both the element and its children. If #render_children is\n   *       set, ThemeManagerInterface::render() will not be called.\n   *       #render_children is usually only set internally by\n   *       ThemeManagerInterface::render() so that we can avoid the situation\n   *       where Renderer::render() called from within a theme preprocess\n   *       function creates an infinite loop.\n   *     - If this element does not have a defined #theme, or the defined #theme\n   *       hook is not implemented, or #render_children is set, then\n   *       Renderer::render() is called recursively on each of the child\n   *       elements of this element, and the result of each is concatenated onto\n   *       #children. This is skipped if #children is not empty at this point.\n   *     - Once #children has been rendered for this element, if #theme is not\n   *       implemented and #markup is set for this element, #markup will be\n   *       prepended to #children.\n   *   - If this element has #states defined then JavaScript state information\n   *     is added to this element's #attached attribute by\n   *     drupal_process_states().\n   *   - If this element has #attached defined then any required libraries,\n   *     JavaScript, CSS, or other custom data are added to the current page by\n   *     \\Drupal\\Core\\Render\\AttachmentsResponseProcessorInterface::processAttachments().\n   *   - If this element has an array of #theme_wrappers defined and\n   *     #render_children is not set, #children is then re-rendered by passing\n   *     the element in its current state to ThemeManagerInterface::render()\n   *     successively for each item in #theme_wrappers. Since #theme and\n   *     #theme_wrappers hooks often define variables with the same names it is\n   *     possible to explicitly override each attribute passed to each\n   *     #theme_wrappers hook by setting the hook name as the key and an array\n   *     of overrides as the value in #theme_wrappers array.\n   *     For example, if we have a render element as follows:\n   *     @code\n   *     array(\n   *       '#theme' => 'image',\n   *       '#attributes' => array('class' => array('foo')),\n   *       '#theme_wrappers' => array('container'),\n   *     );\n   *     @endcode\n   *     and we need to pass the class 'bar' as an attribute for 'container', we\n   *     can rewrite our element thus:\n   *     @code\n   *     array(\n   *       '#theme' => 'image',\n   *       '#attributes' => array('class' => array('foo')),\n   *       '#theme_wrappers' => array(\n   *         'container' => array(\n   *           '#attributes' => array('class' => array('bar')),\n   *         ),\n   *       ),\n   *     );\n   *      @endcode\n   *   - If this element has an array of #post_render functions defined, they\n   *     are called sequentially to modify the rendered #children. Unlike\n   *     #pre_render functions, #post_render functions are passed both the\n   *     rendered #children attribute as a string and the element itself.\n   *   - If this element has #prefix and\/or #suffix defined, they are\n   *     concatenated to #children.\n   *   - The rendering of this element is now complete. The next step will be\n   *     render caching. So this is the perfect time to update the stack. At\n   *     this point, children of this element (if any), have been rendered also,\n   *     and if there were any, their bubbleable rendering metadata will have\n   *     been bubbled up into the stack frame for the element that is currently\n   *     being rendered. The render cache item for this element must contain the\n   *     bubbleable rendering metadata for this element and all of its children.\n   *     However, right now, the topmost stack frame (the one for this element)\n   *     currently only contains the metadata for the children. Therefore, the\n   *     topmost stack frame is updated with this element's metadata, and then\n   *     the element's metadata is replaced with the metadata in the topmost\n   *     stack frame. This element now contains all bubbleable rendering\n   *     metadata for this element and all its children, so it's now ready for\n   *     render caching.\n   *   - If this element has #cache defined, the rendered output of this element\n   *     is saved to Renderer::render()'s internal cache. This includes the\n   *     changes made by #post_render.\n   *     At the same time, if $pre_bubbling_cid is set, it is compared to the\n   *     calculated cache ID. If they are different, then a redirecting cache\n   *     item is created, containing the #cache metadata of the current element,\n   *     and written to cache using the value of $pre_bubbling_cid as the cache\n   *     ID. This ensures the pre-bubbling (\"wrong\") cache ID redirects to the\n   *     post-bubbling (\"right\") cache ID.\n   *   - If this element also has #cache_properties defined, all the array items\n   *     matching the specified property names will be cached along with the\n   *     element markup. If properties include children names, the system\n   *     assumes only children's individual markup is relevant and ignores the\n   *     parent markup. This approach is normally not needed and should be\n   *     adopted only when dealing with very advanced use cases.\n   *   - If this element has attached placeholders ([#attached][placeholders]),\n   *     or any of its children has (which we would know thanks to the stack\n   *     having been updated just before the render caching step), its\n   *     placeholder element containing a #lazy_builder function is rendered in\n   *     isolation. The resulting markup is used to replace the placeholder, and\n   *     any bubbleable metadata is merged.\n   *     Placeholders must be unique, to guarantee that for instance, samples of\n   *     placeholders are not replaced as well.\n   *   - Just before finishing the rendering of this element, this element's\n   *     stack frame (the topmost one) is bubbled: the two topmost frames are\n   *     popped from the stack, they are merged and the result is pushed back\n   *     onto the stack.\n   *     So if for instance this element was a child element, then a new frame\n   *     was pushed onto the stack element at the beginning of rendering this\n   *     element, it was updated when the rendering was completed, and now we\n   *     merge it with the frame for the parent, so that the parent now has the\n   *     bubbleable rendering metadata for its child.\n   *   - #printed is set to TRUE for this element to ensure that it is only\n   *     rendered once.\n   *   - The final value of #children for this element is returned as the\n   *     rendered output.\n   *\n   * @param array $elements\n   *   The structured array describing the data to be rendered.\n   * @param bool $is_root_call\n   *   (Internal use only.) Whether this is a recursive call or not. See\n   *   ::renderRoot().\n   *\n   * @return \\Drupal\\Component\\Render\\MarkupInterface\n   *   The rendered HTML.\n   *\n   * @throws \\LogicException\n   *   When called outside of a render context (i.e. outside of a renderRoot(),\n   *   renderPlain() or executeInRenderContext() call).\n   * @throws \\Exception\n   *   If a #pre_render callback throws an exception, it is caught to mark the\n   *   renderer as no longer being in a root render call, if any. Then the\n   *   exception is rethrown.\n   *\n   * @see \\Drupal\\Core\\Render\\ElementInfoManagerInterface::getInfo()\n   * @see \\Drupal\\Core\\Theme\\ThemeManagerInterface::render()\n   * @see drupal_process_states()\n   * @see \\Drupal\\Core\\Render\\AttachmentsResponseProcessorInterface::processAttachments()\n   * @see \\Drupal\\Core\\Render\\RendererInterface::renderRoot()\n   *\/",82],["T_WHITESPACE","\n  ",334],["T_PUBLIC","public",335],["T_WHITESPACE"," ",335],["T_FUNCTION","function",335],["T_WHITESPACE"," ",335],["T_STRING","render",335],"(","&",["T_VARIABLE","$elements",335],",",["T_WHITESPACE"," ",335],["T_VARIABLE","$is_root_call",335],["T_WHITESPACE"," ",335],"=",["T_WHITESPACE"," ",335],["T_STRING","FALSE",335],")",";",["T_WHITESPACE","\n\n  ",335],["T_DOC_COMMENT","\/**\n   * Checks whether a render context is active.\n   *\n   * This is useful only in very specific situations to determine whether the\n   * system is already capable of collecting bubbleable metadata. Normally it\n   * should not be necessary to be concerned about this.\n   *\n   * @return bool\n   *   TRUE if the renderer has a render context active, FALSE otherwise.\n   *\/",337],["T_WHITESPACE","\n  ",346],["T_PUBLIC","public",347],["T_WHITESPACE"," ",347],["T_FUNCTION","function",347],["T_WHITESPACE"," ",347],["T_STRING","hasRenderContext",347],"(",")",";",["T_WHITESPACE","\n\n  ",347],["T_DOC_COMMENT","\/**\n   * Executes a callable within a render context.\n   *\n   * Only for very advanced use cases. Prefer using ::renderRoot() and\n   * ::renderPlain() instead.\n   *\n   * All rendering must happen within a render context. Within a render context,\n   * all bubbleable metadata is bubbled and hence tracked. Outside of a render\n   * context, it would be lost. This could lead to missing assets, incorrect\n   * cache variations (and thus security issues), insufficient cache\n   * invalidations, and so on.\n   *\n   * Any and all rendering must therefore happen within a render context, and it\n   * is this method that provides that.\n   *\n   * @param \\Drupal\\Core\\Render\\RenderContext $context\n   *   The render context to execute the callable within.\n   * @param callable $callable\n   *   The callable to execute.\n   *\n   * @return mixed\n   *   The callable's return value.\n   *\n   * @throws \\LogicException\n   *   In case bubbling has failed, can only happen in case of broken code.\n   *\n   * @see \\Drupal\\Core\\Render\\RenderContext\n   * @see \\Drupal\\Core\\Render\\BubbleableMetadata\n   *\/",349],["T_WHITESPACE","\n  ",377],["T_PUBLIC","public",378],["T_WHITESPACE"," ",378],["T_FUNCTION","function",378],["T_WHITESPACE"," ",378],["T_STRING","executeInRenderContext",378],"(",["T_STRING","RenderContext",378],["T_WHITESPACE"," ",378],["T_VARIABLE","$context",378],",",["T_WHITESPACE"," ",378],["T_CALLABLE","callable",378],["T_WHITESPACE"," ",378],["T_VARIABLE","$callable",378],")",";",["T_WHITESPACE","\n\n  ",378],["T_DOC_COMMENT","\/**\n   * Merges the bubbleable rendering metadata o\/t 2nd render array with the 1st.\n   *\n   * @param array $a\n   *   A render array.\n   * @param array $b\n   *   A render array.\n   *\n   * @return array\n   *   The first render array, modified to also contain the bubbleable rendering\n   *   metadata of the second render array.\n   *\n   * @see \\Drupal\\Core\\Render\\BubbleableMetadata\n   *\/",380],["T_WHITESPACE","\n  ",393],["T_PUBLIC","public",394],["T_WHITESPACE"," ",394],["T_FUNCTION","function",394],["T_WHITESPACE"," ",394],["T_STRING","mergeBubbleableMetadata",394],"(",["T_ARRAY","array",394],["T_WHITESPACE"," ",394],["T_VARIABLE","$a",394],",",["T_WHITESPACE"," ",394],["T_ARRAY","array",394],["T_WHITESPACE"," ",394],["T_VARIABLE","$b",394],")",";",["T_WHITESPACE","\n\n  ",394],["T_DOC_COMMENT","\/**\n   * Adds a dependency on an object: merges its cacheability metadata.\n   *\n   * For instance, when a render array depends on some configuration, an entity,\n   * or an access result, we must make sure their cacheability metadata is\n   * present on the render array. This method makes doing that simple.\n   *\n   * @param array &$elements\n   *   The render array to update.\n   * @param \\Drupal\\Core\\Cache\\CacheableDependencyInterface|mixed $dependency\n   *   The dependency. If the object implements CacheableDependencyInterface,\n   *   then its cacheability metadata will be used. Otherwise, the passed in\n   *   object must be assumed to be uncacheable, so max-age 0 is set.\n   *\n   * @see \\Drupal\\Core\\Cache\\CacheableMetadata::createFromObject()\n   *\/",396],["T_WHITESPACE","\n  ",411],["T_PUBLIC","public",412],["T_WHITESPACE"," ",412],["T_FUNCTION","function",412],["T_WHITESPACE"," ",412],["T_STRING","addCacheableDependency",412],"(",["T_ARRAY","array",412],["T_WHITESPACE"," ",412],"&",["T_VARIABLE","$elements",412],",",["T_WHITESPACE"," ",412],["T_VARIABLE","$dependency",412],")",";",["T_WHITESPACE","\n\n",412],"}",["T_WHITESPACE","\n",414]]