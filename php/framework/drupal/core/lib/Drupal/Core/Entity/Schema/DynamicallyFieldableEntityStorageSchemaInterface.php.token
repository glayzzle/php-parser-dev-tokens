[["T_OPEN_TAG","<?php\n",1],["T_WHITESPACE","\n",2],["T_NAMESPACE","namespace",3],["T_WHITESPACE"," ",3],["T_STRING","Drupal",3],["T_NS_SEPARATOR","\\",3],["T_STRING","Core",3],["T_NS_SEPARATOR","\\",3],["T_STRING","Entity",3],["T_NS_SEPARATOR","\\",3],["T_STRING","Schema",3],";",["T_WHITESPACE","\n\n",3],["T_USE","use",5],["T_WHITESPACE"," ",5],["T_STRING","Drupal",5],["T_NS_SEPARATOR","\\",5],["T_STRING","Core",5],["T_NS_SEPARATOR","\\",5],["T_STRING","Field",5],["T_NS_SEPARATOR","\\",5],["T_STRING","FieldStorageDefinitionInterface",5],";",["T_WHITESPACE","\n",5],["T_USE","use",6],["T_WHITESPACE"," ",6],["T_STRING","Drupal",6],["T_NS_SEPARATOR","\\",6],["T_STRING","Core",6],["T_NS_SEPARATOR","\\",6],["T_STRING","Field",6],["T_NS_SEPARATOR","\\",6],["T_STRING","FieldStorageDefinitionListenerInterface",6],";",["T_WHITESPACE","\n\n",6],["T_DOC_COMMENT","\/**\n * A storage schema that supports entity types with dynamic field definitions.\n *\n * A storage schema that implements this interface can react to the entity\n * type's field definitions changing, due to modules being installed or\n * uninstalled, or via field UI, or via code changes to the entity class.\n *\n * For example, configurable fields defined and exposed by field.module.\n *\/",8],["T_WHITESPACE","\n",16],["T_INTERFACE","interface",17],["T_WHITESPACE"," ",17],["T_STRING","DynamicallyFieldableEntityStorageSchemaInterface",17],["T_WHITESPACE"," ",17],["T_EXTENDS","extends",17],["T_WHITESPACE"," ",17],["T_STRING","EntityStorageSchemaInterface",17],",",["T_WHITESPACE"," ",17],["T_STRING","FieldStorageDefinitionListenerInterface",17],["T_WHITESPACE"," ",17],"{",["T_WHITESPACE","\n\n  ",17],["T_DOC_COMMENT","\/**\n   * Checks if the changes to the storage definition requires schema changes.\n   *\n   * @param \\Drupal\\Core\\Field\\FieldStorageDefinitionInterface $storage_definition\n   *   The updated field storage definition.\n   * @param \\Drupal\\Core\\Field\\FieldStorageDefinitionInterface $original\n   *   The original field storage definition.\n   *\n   * @return bool\n   *   TRUE if storage schema changes are required, FALSE otherwise.\n   *\/",19],["T_WHITESPACE","\n  ",29],["T_PUBLIC","public",30],["T_WHITESPACE"," ",30],["T_FUNCTION","function",30],["T_WHITESPACE"," ",30],["T_STRING","requiresFieldStorageSchemaChanges",30],"(",["T_STRING","FieldStorageDefinitionInterface",30],["T_WHITESPACE"," ",30],["T_VARIABLE","$storage_definition",30],",",["T_WHITESPACE"," ",30],["T_STRING","FieldStorageDefinitionInterface",30],["T_WHITESPACE"," ",30],["T_VARIABLE","$original",30],")",";",["T_WHITESPACE","\n\n  ",30],["T_DOC_COMMENT","\/**\n   * Checks if existing data would be lost if the schema changes were applied.\n   *\n   * If there are no schema changes needed, then no data needs to be migrated,\n   * but it is not the responsibility of this function to recheck what\n   * requiresFieldStorageSchemaChanges() checks. Rather, the meaning of what\n   * this function returns when requiresFieldStorageSchemaChanges() returns\n   * FALSE is undefined. Callers are expected to only call this function when\n   * requiresFieldStorageSchemaChanges() is TRUE.\n   *\n   * This function can return FALSE if any of these conditions apply:\n   * - There are no existing entities for the entity type to which this field\n   *   is attached.\n   * - There are existing entities, but none with existing values for this\n   *   field.\n   * - There are existing field values, but the schema changes can be applied\n   *   without losing them (e.g., if the schema changes can be performed by\n   *   altering tables rather than dropping and recreating them).\n   * - The only field values that would be lost are ones that are not valid for\n   *   the new definition (e.g., if changing a field from revisionable to\n   *   non-revisionable, then it's okay to drop data for the non-default\n   *   revision).\n   *\n   * When this function returns FALSE, site administrators will be unable to\n   * perform an automated update, and will instead need to perform a site\n   * migration or invoke some custom update process.\n   *\n   * @param \\Drupal\\Core\\Field\\FieldStorageDefinitionInterface $storage_definition\n   *   The updated field storage definition.\n   * @param \\Drupal\\Core\\Field\\FieldStorageDefinitionInterface $original\n   *   The original field storage definition.\n   *\n   * @return bool\n   *   TRUE if data migration is required, FALSE otherwise.\n   *\n   * @see self::requiresFieldStorageSchemaChanges()\n   *\/",32],["T_WHITESPACE","\n  ",68],["T_PUBLIC","public",69],["T_WHITESPACE"," ",69],["T_FUNCTION","function",69],["T_WHITESPACE"," ",69],["T_STRING","requiresFieldDataMigration",69],"(",["T_STRING","FieldStorageDefinitionInterface",69],["T_WHITESPACE"," ",69],["T_VARIABLE","$storage_definition",69],",",["T_WHITESPACE"," ",69],["T_STRING","FieldStorageDefinitionInterface",69],["T_WHITESPACE"," ",69],["T_VARIABLE","$original",69],")",";",["T_WHITESPACE","\n\n  ",69],["T_DOC_COMMENT","\/**\n   * Performs final cleanup after all data of a field has been purged.\n   *\n   * @param \\Drupal\\Core\\Field\\FieldStorageDefinitionInterface $storage_definition\n   *   The field being purged.\n   *\/",71],["T_WHITESPACE","\n  ",76],["T_PUBLIC","public",77],["T_WHITESPACE"," ",77],["T_FUNCTION","function",77],["T_WHITESPACE"," ",77],["T_STRING","finalizePurge",77],"(",["T_STRING","FieldStorageDefinitionInterface",77],["T_WHITESPACE"," ",77],["T_VARIABLE","$storage_definition",77],")",";",["T_WHITESPACE","\n\n",77],"}",["T_WHITESPACE","\n",79]]