[["T_OPEN_TAG","<?php\n",1],["T_WHITESPACE","\n",2],["T_NAMESPACE","namespace",3],["T_WHITESPACE"," ",3],["T_STRING","Drupal",3],["T_NS_SEPARATOR","\\",3],["T_STRING","Component",3],["T_NS_SEPARATOR","\\",3],["T_STRING","Utility",3],";",["T_WHITESPACE","\n\n",3],["T_DOC_COMMENT","\/**\n * Provides helpers to perform operations on nested arrays and array keys of variable depth.\n *\n * @ingroup utility\n *\/",5],["T_WHITESPACE","\n",9],["T_CLASS","class",10],["T_WHITESPACE"," ",10],["T_STRING","NestedArray",10],["T_WHITESPACE"," ",10],"{",["T_WHITESPACE","\n\n  ",10],["T_DOC_COMMENT","\/**\n   * Retrieves a value from a nested array with variable depth.\n   *\n   * This helper function should be used when the depth of the array element\n   * being retrieved may vary (that is, the number of parent keys is variable).\n   * It is primarily used for form structures and renderable arrays.\n   *\n   * Without this helper function the only way to get a nested array value with\n   * variable depth in one line would be using eval(), which should be avoided:\n   * @code\n   * \/\/ Do not do this! Avoid eval().\n   * \/\/ May also throw a PHP notice, if the variable array keys do not exist.\n   * eval('$value = $array[\\'' . implode(\"']['\", $parents) . \"'];\");\n   * @endcode\n   *\n   * Instead, use this helper function:\n   * @code\n   * $value = NestedArray::getValue($form, $parents);\n   * @endcode\n   *\n   * A return value of NULL is ambiguous, and can mean either that the requested\n   * key does not exist, or that the actual value is NULL. If it is required to\n   * know whether the nested array key actually exists, pass a third argument\n   * that is altered by reference:\n   * @code\n   * $key_exists = NULL;\n   * $value = NestedArray::getValue($form, $parents, $key_exists);\n   * if ($key_exists) {\n   *   \/\/ Do something with $value.\n   * }\n   * @endcode\n   *\n   * However if the number of array parent keys is static, the value should\n   * always be retrieved directly rather than calling this function.\n   * For instance:\n   * @code\n   * $value = $form['signature_settings']['signature'];\n   * @endcode\n   *\n   * @param array $array\n   *   The array from which to get the value.\n   * @param array $parents\n   *   An array of parent keys of the value, starting with the outermost key.\n   * @param bool $key_exists\n   *   (optional) If given, an already defined variable that is altered by\n   *   reference.\n   *\n   * @return mixed\n   *   The requested nested value. Possibly NULL if the value is NULL or not all\n   *   nested parent keys exist. $key_exists is altered by reference and is a\n   *   Boolean that indicates whether all nested parent keys exist (TRUE) or not\n   *   (FALSE). This allows to distinguish between the two possibilities when\n   *   NULL is returned.\n   *\n   * @see NestedArray::setValue()\n   * @see NestedArray::unsetValue()\n   *\/",12],["T_WHITESPACE","\n  ",68],["T_PUBLIC","public",69],["T_WHITESPACE"," ",69],["T_STATIC","static",69],["T_WHITESPACE"," ",69],["T_FUNCTION","function",69],["T_WHITESPACE"," ",69],"&",["T_STRING","getValue",69],"(",["T_ARRAY","array",69],["T_WHITESPACE"," ",69],"&",["T_VARIABLE","$array",69],",",["T_WHITESPACE"," ",69],["T_ARRAY","array",69],["T_WHITESPACE"," ",69],["T_VARIABLE","$parents",69],",",["T_WHITESPACE"," ",69],"&",["T_VARIABLE","$key_exists",69],["T_WHITESPACE"," ",69],"=",["T_WHITESPACE"," ",69],["T_STRING","NULL",69],")",["T_WHITESPACE"," ",69],"{",["T_WHITESPACE","\n    ",69],["T_VARIABLE","$ref",70],["T_WHITESPACE"," ",70],"=",["T_WHITESPACE"," ",70],"&",["T_VARIABLE","$array",70],";",["T_WHITESPACE","\n    ",70],["T_FOREACH","foreach",71],["T_WHITESPACE"," ",71],"(",["T_VARIABLE","$parents",71],["T_WHITESPACE"," ",71],["T_AS","as",71],["T_WHITESPACE"," ",71],["T_VARIABLE","$parent",71],")",["T_WHITESPACE"," ",71],"{",["T_WHITESPACE","\n      ",71],["T_IF","if",72],["T_WHITESPACE"," ",72],"(",["T_STRING","is_array",72],"(",["T_VARIABLE","$ref",72],")",["T_WHITESPACE"," ",72],["T_BOOLEAN_AND","&&",72],["T_WHITESPACE"," ",72],["T_STRING","array_key_exists",72],"(",["T_VARIABLE","$parent",72],",",["T_WHITESPACE"," ",72],["T_VARIABLE","$ref",72],")",")",["T_WHITESPACE"," ",72],"{",["T_WHITESPACE","\n        ",72],["T_VARIABLE","$ref",73],["T_WHITESPACE"," ",73],"=",["T_WHITESPACE"," ",73],"&",["T_VARIABLE","$ref",73],"[",["T_VARIABLE","$parent",73],"]",";",["T_WHITESPACE","\n      ",73],"}",["T_WHITESPACE","\n      ",74],["T_ELSE","else",75],["T_WHITESPACE"," ",75],"{",["T_WHITESPACE","\n        ",75],["T_VARIABLE","$key_exists",76],["T_WHITESPACE"," ",76],"=",["T_WHITESPACE"," ",76],["T_STRING","FALSE",76],";",["T_WHITESPACE","\n        ",76],["T_VARIABLE","$null",77],["T_WHITESPACE"," ",77],"=",["T_WHITESPACE"," ",77],["T_STRING","NULL",77],";",["T_WHITESPACE","\n        ",77],["T_RETURN","return",78],["T_WHITESPACE"," ",78],["T_VARIABLE","$null",78],";",["T_WHITESPACE","\n      ",78],"}",["T_WHITESPACE","\n    ",79],"}",["T_WHITESPACE","\n    ",80],["T_VARIABLE","$key_exists",81],["T_WHITESPACE"," ",81],"=",["T_WHITESPACE"," ",81],["T_STRING","TRUE",81],";",["T_WHITESPACE","\n    ",81],["T_RETURN","return",82],["T_WHITESPACE"," ",82],["T_VARIABLE","$ref",82],";",["T_WHITESPACE","\n  ",82],"}",["T_WHITESPACE","\n\n  ",83],["T_DOC_COMMENT","\/**\n   * Sets a value in a nested array with variable depth.\n   *\n   * This helper function should be used when the depth of the array element you\n   * are changing may vary (that is, the number of parent keys is variable). It\n   * is primarily used for form structures and renderable arrays.\n   *\n   * Example:\n   * @code\n   * \/\/ Assume you have a 'signature' element somewhere in a form. It might be:\n   * $form['signature_settings']['signature'] = array(\n   *   '#type' => 'text_format',\n   *   '#title' => t('Signature'),\n   * );\n   * \/\/ Or, it might be further nested:\n   * $form['signature_settings']['user']['signature'] = array(\n   *   '#type' => 'text_format',\n   *   '#title' => t('Signature'),\n   * );\n   * @endcode\n   *\n   * To deal with the situation, the code needs to figure out the route to the\n   * element, given an array of parents that is either\n   * @code array('signature_settings', 'signature') @endcode\n   * in the first case or\n   * @code array('signature_settings', 'user', 'signature') @endcode\n   * in the second case.\n   *\n   * Without this helper function the only way to set the signature element in\n   * one line would be using eval(), which should be avoided:\n   * @code\n   * \/\/ Do not do this! Avoid eval().\n   * eval('$form[\\'' . implode(\"']['\", $parents) . '\\'] = $element;');\n   * @endcode\n   *\n   * Instead, use this helper function:\n   * @code\n   * NestedArray::setValue($form, $parents, $element);\n   * @endcode\n   *\n   * However if the number of array parent keys is static, the value should\n   * always be set directly rather than calling this function. For instance,\n   * for the first example we could just do:\n   * @code\n   * $form['signature_settings']['signature'] = $element;\n   * @endcode\n   *\n   * @param array $array\n   *   A reference to the array to modify.\n   * @param array $parents\n   *   An array of parent keys, starting with the outermost key.\n   * @param mixed $value\n   *   The value to set.\n   * @param bool $force\n   *   (optional) If TRUE, the value is forced into the structure even if it\n   *   requires the deletion of an already existing non-array parent value. If\n   *   FALSE, PHP throws an error if trying to add into a value that is not an\n   *   array. Defaults to FALSE.\n   *\n   * @see NestedArray::unsetValue()\n   * @see NestedArray::getValue()\n   *\/",85],["T_WHITESPACE","\n  ",146],["T_PUBLIC","public",147],["T_WHITESPACE"," ",147],["T_STATIC","static",147],["T_WHITESPACE"," ",147],["T_FUNCTION","function",147],["T_WHITESPACE"," ",147],["T_STRING","setValue",147],"(",["T_ARRAY","array",147],["T_WHITESPACE"," ",147],"&",["T_VARIABLE","$array",147],",",["T_WHITESPACE"," ",147],["T_ARRAY","array",147],["T_WHITESPACE"," ",147],["T_VARIABLE","$parents",147],",",["T_WHITESPACE"," ",147],["T_VARIABLE","$value",147],",",["T_WHITESPACE"," ",147],["T_VARIABLE","$force",147],["T_WHITESPACE"," ",147],"=",["T_WHITESPACE"," ",147],["T_STRING","FALSE",147],")",["T_WHITESPACE"," ",147],"{",["T_WHITESPACE","\n    ",147],["T_VARIABLE","$ref",148],["T_WHITESPACE"," ",148],"=",["T_WHITESPACE"," ",148],"&",["T_VARIABLE","$array",148],";",["T_WHITESPACE","\n    ",148],["T_FOREACH","foreach",149],["T_WHITESPACE"," ",149],"(",["T_VARIABLE","$parents",149],["T_WHITESPACE"," ",149],["T_AS","as",149],["T_WHITESPACE"," ",149],["T_VARIABLE","$parent",149],")",["T_WHITESPACE"," ",149],"{",["T_WHITESPACE","\n      ",149],["T_COMMENT","\/\/ PHP auto-creates container arrays and NULL entries without error if $ref\n",150],["T_WHITESPACE","      ",151],["T_COMMENT","\/\/ is NULL, but throws an error if $ref is set, but not an array.\n",151],["T_WHITESPACE","      ",152],["T_IF","if",152],["T_WHITESPACE"," ",152],"(",["T_VARIABLE","$force",152],["T_WHITESPACE"," ",152],["T_BOOLEAN_AND","&&",152],["T_WHITESPACE"," ",152],["T_ISSET","isset",152],"(",["T_VARIABLE","$ref",152],")",["T_WHITESPACE"," ",152],["T_BOOLEAN_AND","&&",152],["T_WHITESPACE"," ",152],"!",["T_STRING","is_array",152],"(",["T_VARIABLE","$ref",152],")",")",["T_WHITESPACE"," ",152],"{",["T_WHITESPACE","\n        ",152],["T_VARIABLE","$ref",153],["T_WHITESPACE"," ",153],"=",["T_WHITESPACE"," ",153],["T_ARRAY","array",153],"(",")",";",["T_WHITESPACE","\n      ",153],"}",["T_WHITESPACE","\n      ",154],["T_VARIABLE","$ref",155],["T_WHITESPACE"," ",155],"=",["T_WHITESPACE"," ",155],"&",["T_VARIABLE","$ref",155],"[",["T_VARIABLE","$parent",155],"]",";",["T_WHITESPACE","\n    ",155],"}",["T_WHITESPACE","\n    ",156],["T_VARIABLE","$ref",157],["T_WHITESPACE"," ",157],"=",["T_WHITESPACE"," ",157],["T_VARIABLE","$value",157],";",["T_WHITESPACE","\n  ",157],"}",["T_WHITESPACE","\n\n  ",158],["T_DOC_COMMENT","\/**\n   * Unsets a value in a nested array with variable depth.\n   *\n   * This helper function should be used when the depth of the array element you\n   * are changing may vary (that is, the number of parent keys is variable). It\n   * is primarily used for form structures and renderable arrays.\n   *\n   * Example:\n   * @code\n   * \/\/ Assume you have a 'signature' element somewhere in a form. It might be:\n   * $form['signature_settings']['signature'] = array(\n   *   '#type' => 'text_format',\n   *   '#title' => t('Signature'),\n   * );\n   * \/\/ Or, it might be further nested:\n   * $form['signature_settings']['user']['signature'] = array(\n   *   '#type' => 'text_format',\n   *   '#title' => t('Signature'),\n   * );\n   * @endcode\n   *\n   * To deal with the situation, the code needs to figure out the route to the\n   * element, given an array of parents that is either\n   * @code array('signature_settings', 'signature') @endcode\n   * in the first case or\n   * @code array('signature_settings', 'user', 'signature') @endcode\n   * in the second case.\n   *\n   * Without this helper function the only way to unset the signature element in\n   * one line would be using eval(), which should be avoided:\n   * @code\n   * \/\/ Do not do this! Avoid eval().\n   * eval('unset($form[\\'' . implode(\"']['\", $parents) . '\\']);');\n   * @endcode\n   *\n   * Instead, use this helper function:\n   * @code\n   * NestedArray::unset_nested_value($form, $parents, $element);\n   * @endcode\n   *\n   * However if the number of array parent keys is static, the value should\n   * always be set directly rather than calling this function. For instance, for\n   * the first example we could just do:\n   * @code\n   * unset($form['signature_settings']['signature']);\n   * @endcode\n   *\n   * @param array $array\n   *   A reference to the array to modify.\n   * @param array $parents\n   *   An array of parent keys, starting with the outermost key and including\n   *   the key to be unset.\n   * @param bool $key_existed\n   *   (optional) If given, an already defined variable that is altered by\n   *   reference.\n   *\n   * @see NestedArray::setValue()\n   * @see NestedArray::getValue()\n   *\/",160],["T_WHITESPACE","\n  ",218],["T_PUBLIC","public",219],["T_WHITESPACE"," ",219],["T_STATIC","static",219],["T_WHITESPACE"," ",219],["T_FUNCTION","function",219],["T_WHITESPACE"," ",219],["T_STRING","unsetValue",219],"(",["T_ARRAY","array",219],["T_WHITESPACE"," ",219],"&",["T_VARIABLE","$array",219],",",["T_WHITESPACE"," ",219],["T_ARRAY","array",219],["T_WHITESPACE"," ",219],["T_VARIABLE","$parents",219],",",["T_WHITESPACE"," ",219],"&",["T_VARIABLE","$key_existed",219],["T_WHITESPACE"," ",219],"=",["T_WHITESPACE"," ",219],["T_STRING","NULL",219],")",["T_WHITESPACE"," ",219],"{",["T_WHITESPACE","\n    ",219],["T_VARIABLE","$unset_key",220],["T_WHITESPACE"," ",220],"=",["T_WHITESPACE"," ",220],["T_STRING","array_pop",220],"(",["T_VARIABLE","$parents",220],")",";",["T_WHITESPACE","\n    ",220],["T_VARIABLE","$ref",221],["T_WHITESPACE"," ",221],"=",["T_WHITESPACE"," ",221],"&",["T_STRING","self",221],["T_DOUBLE_COLON","::",221],["T_STRING","getValue",221],"(",["T_VARIABLE","$array",221],",",["T_WHITESPACE"," ",221],["T_VARIABLE","$parents",221],",",["T_WHITESPACE"," ",221],["T_VARIABLE","$key_existed",221],")",";",["T_WHITESPACE","\n    ",221],["T_IF","if",222],["T_WHITESPACE"," ",222],"(",["T_VARIABLE","$key_existed",222],["T_WHITESPACE"," ",222],["T_BOOLEAN_AND","&&",222],["T_WHITESPACE"," ",222],["T_STRING","is_array",222],"(",["T_VARIABLE","$ref",222],")",["T_WHITESPACE"," ",222],["T_BOOLEAN_AND","&&",222],["T_WHITESPACE"," ",222],["T_STRING","array_key_exists",222],"(",["T_VARIABLE","$unset_key",222],",",["T_WHITESPACE"," ",222],["T_VARIABLE","$ref",222],")",")",["T_WHITESPACE"," ",222],"{",["T_WHITESPACE","\n      ",222],["T_VARIABLE","$key_existed",223],["T_WHITESPACE"," ",223],"=",["T_WHITESPACE"," ",223],["T_STRING","TRUE",223],";",["T_WHITESPACE","\n      ",223],["T_UNSET","unset",224],"(",["T_VARIABLE","$ref",224],"[",["T_VARIABLE","$unset_key",224],"]",")",";",["T_WHITESPACE","\n    ",224],"}",["T_WHITESPACE","\n    ",225],["T_ELSE","else",226],["T_WHITESPACE"," ",226],"{",["T_WHITESPACE","\n      ",226],["T_VARIABLE","$key_existed",227],["T_WHITESPACE"," ",227],"=",["T_WHITESPACE"," ",227],["T_STRING","FALSE",227],";",["T_WHITESPACE","\n    ",227],"}",["T_WHITESPACE","\n  ",228],"}",["T_WHITESPACE","\n\n  ",229],["T_DOC_COMMENT","\/**\n   * Determines whether a nested array contains the requested keys.\n   *\n   * This helper function should be used when the depth of the array element to\n   * be checked may vary (that is, the number of parent keys is variable). See\n   * NestedArray::setValue() for details. It is primarily used for form\n   * structures and renderable arrays.\n   *\n   * If it is required to also get the value of the checked nested key, use\n   * NestedArray::getValue() instead.\n   *\n   * If the number of array parent keys is static, this helper function is\n   * unnecessary and the following code can be used instead:\n   * @code\n   * $value_exists = isset($form['signature_settings']['signature']);\n   * $key_exists = array_key_exists('signature', $form['signature_settings']);\n   * @endcode\n   *\n   * @param array $array\n   *   The array with the value to check for.\n   * @param array $parents\n   *   An array of parent keys of the value, starting with the outermost key.\n   *\n   * @return bool\n   *   TRUE if all the parent keys exist, FALSE otherwise.\n   *\n   * @see NestedArray::getValue()\n   *\/",231],["T_WHITESPACE","\n  ",258],["T_PUBLIC","public",259],["T_WHITESPACE"," ",259],["T_STATIC","static",259],["T_WHITESPACE"," ",259],["T_FUNCTION","function",259],["T_WHITESPACE"," ",259],["T_STRING","keyExists",259],"(",["T_ARRAY","array",259],["T_WHITESPACE"," ",259],["T_VARIABLE","$array",259],",",["T_WHITESPACE"," ",259],["T_ARRAY","array",259],["T_WHITESPACE"," ",259],["T_VARIABLE","$parents",259],")",["T_WHITESPACE"," ",259],"{",["T_WHITESPACE","\n    ",259],["T_COMMENT","\/\/ Although this function is similar to PHP's array_key_exists(), its\n",260],["T_WHITESPACE","    ",261],["T_COMMENT","\/\/ arguments should be consistent with getValue().\n",261],["T_WHITESPACE","    ",262],["T_VARIABLE","$key_exists",262],["T_WHITESPACE"," ",262],"=",["T_WHITESPACE"," ",262],["T_STRING","NULL",262],";",["T_WHITESPACE","\n    ",262],["T_STRING","self",263],["T_DOUBLE_COLON","::",263],["T_STRING","getValue",263],"(",["T_VARIABLE","$array",263],",",["T_WHITESPACE"," ",263],["T_VARIABLE","$parents",263],",",["T_WHITESPACE"," ",263],["T_VARIABLE","$key_exists",263],")",";",["T_WHITESPACE","\n    ",263],["T_RETURN","return",264],["T_WHITESPACE"," ",264],["T_VARIABLE","$key_exists",264],";",["T_WHITESPACE","\n  ",264],"}",["T_WHITESPACE","\n\n  ",265],["T_DOC_COMMENT","\/**\n   * Merges multiple arrays, recursively, and returns the merged array.\n   *\n   * This function is similar to PHP's array_merge_recursive() function, but it\n   * handles non-array values differently. When merging values that are not both\n   * arrays, the latter value replaces the former rather than merging with it.\n   *\n   * Example:\n   * @code\n   * $link_options_1 = array('fragment' => 'x', 'attributes' => array('title' => t('X'), 'class' => array('a', 'b')));\n   * $link_options_2 = array('fragment' => 'y', 'attributes' => array('title' => t('Y'), 'class' => array('c', 'd')));\n   *\n   * \/\/ This results in array('fragment' => array('x', 'y'), 'attributes' => array('title' => array(t('X'), t('Y')), 'class' => array('a', 'b', 'c', 'd'))).\n   * $incorrect = array_merge_recursive($link_options_1, $link_options_2);\n   *\n   * \/\/ This results in array('fragment' => 'y', 'attributes' => array('title' => t('Y'), 'class' => array('a', 'b', 'c', 'd'))).\n   * $correct = NestedArray::mergeDeep($link_options_1, $link_options_2);\n   * @endcode\n   *\n   * @param array ...\n   *   Arrays to merge.\n   *\n   * @return array\n   *   The merged array.\n   *\n   * @see NestedArray::mergeDeepArray()\n   *\/",267],["T_WHITESPACE","\n  ",293],["T_PUBLIC","public",294],["T_WHITESPACE"," ",294],["T_STATIC","static",294],["T_WHITESPACE"," ",294],["T_FUNCTION","function",294],["T_WHITESPACE"," ",294],["T_STRING","mergeDeep",294],"(",")",["T_WHITESPACE"," ",294],"{",["T_WHITESPACE","\n    ",294],["T_RETURN","return",295],["T_WHITESPACE"," ",295],["T_STRING","self",295],["T_DOUBLE_COLON","::",295],["T_STRING","mergeDeepArray",295],"(",["T_STRING","func_get_args",295],"(",")",")",";",["T_WHITESPACE","\n  ",295],"}",["T_WHITESPACE","\n\n  ",296],["T_DOC_COMMENT","\/**\n   * Merges multiple arrays, recursively, and returns the merged array.\n   *\n   * This function is equivalent to NestedArray::mergeDeep(), except the\n   * input arrays are passed as a single array parameter rather than a variable\n   * parameter list.\n   *\n   * The following are equivalent:\n   * - NestedArray::mergeDeep($a, $b);\n   * - NestedArray::mergeDeepArray(array($a, $b));\n   *\n   * The following are also equivalent:\n   * - call_user_func_array('NestedArray::mergeDeep', $arrays_to_merge);\n   * - NestedArray::mergeDeepArray($arrays_to_merge);\n   *\n   * @param array $arrays\n   *   An arrays of arrays to merge.\n   * @param bool $preserve_integer_keys\n   *   (optional) If given, integer keys will be preserved and merged instead of\n   *   appended. Defaults to FALSE.\n   *\n   * @return array\n   *   The merged array.\n   *\n   * @see NestedArray::mergeDeep()\n   *\/",298],["T_WHITESPACE","\n  ",323],["T_PUBLIC","public",324],["T_WHITESPACE"," ",324],["T_STATIC","static",324],["T_WHITESPACE"," ",324],["T_FUNCTION","function",324],["T_WHITESPACE"," ",324],["T_STRING","mergeDeepArray",324],"(",["T_ARRAY","array",324],["T_WHITESPACE"," ",324],["T_VARIABLE","$arrays",324],",",["T_WHITESPACE"," ",324],["T_VARIABLE","$preserve_integer_keys",324],["T_WHITESPACE"," ",324],"=",["T_WHITESPACE"," ",324],["T_STRING","FALSE",324],")",["T_WHITESPACE"," ",324],"{",["T_WHITESPACE","\n    ",324],["T_VARIABLE","$result",325],["T_WHITESPACE"," ",325],"=",["T_WHITESPACE"," ",325],["T_ARRAY","array",325],"(",")",";",["T_WHITESPACE","\n    ",325],["T_FOREACH","foreach",326],["T_WHITESPACE"," ",326],"(",["T_VARIABLE","$arrays",326],["T_WHITESPACE"," ",326],["T_AS","as",326],["T_WHITESPACE"," ",326],["T_VARIABLE","$array",326],")",["T_WHITESPACE"," ",326],"{",["T_WHITESPACE","\n      ",326],["T_FOREACH","foreach",327],["T_WHITESPACE"," ",327],"(",["T_VARIABLE","$array",327],["T_WHITESPACE"," ",327],["T_AS","as",327],["T_WHITESPACE"," ",327],["T_VARIABLE","$key",327],["T_WHITESPACE"," ",327],["T_DOUBLE_ARROW","=>",327],["T_WHITESPACE"," ",327],["T_VARIABLE","$value",327],")",["T_WHITESPACE"," ",327],"{",["T_WHITESPACE","\n        ",327],["T_COMMENT","\/\/ Renumber integer keys as array_merge_recursive() does unless\n",328],["T_WHITESPACE","        ",329],["T_COMMENT","\/\/ $preserve_integer_keys is set to TRUE. Note that PHP automatically\n",329],["T_WHITESPACE","        ",330],["T_COMMENT","\/\/ converts array keys that are integer strings (e.g., '1') to integers.\n",330],["T_WHITESPACE","        ",331],["T_IF","if",331],["T_WHITESPACE"," ",331],"(",["T_STRING","is_integer",331],"(",["T_VARIABLE","$key",331],")",["T_WHITESPACE"," ",331],["T_BOOLEAN_AND","&&",331],["T_WHITESPACE"," ",331],"!",["T_VARIABLE","$preserve_integer_keys",331],")",["T_WHITESPACE"," ",331],"{",["T_WHITESPACE","\n          ",331],["T_VARIABLE","$result",332],"[","]",["T_WHITESPACE"," ",332],"=",["T_WHITESPACE"," ",332],["T_VARIABLE","$value",332],";",["T_WHITESPACE","\n        ",332],"}",["T_WHITESPACE","\n        ",333],["T_COMMENT","\/\/ Recurse when both values are arrays.\n",334],["T_WHITESPACE","        ",335],["T_ELSEIF","elseif",335],["T_WHITESPACE"," ",335],"(",["T_ISSET","isset",335],"(",["T_VARIABLE","$result",335],"[",["T_VARIABLE","$key",335],"]",")",["T_WHITESPACE"," ",335],["T_BOOLEAN_AND","&&",335],["T_WHITESPACE"," ",335],["T_STRING","is_array",335],"(",["T_VARIABLE","$result",335],"[",["T_VARIABLE","$key",335],"]",")",["T_WHITESPACE"," ",335],["T_BOOLEAN_AND","&&",335],["T_WHITESPACE"," ",335],["T_STRING","is_array",335],"(",["T_VARIABLE","$value",335],")",")",["T_WHITESPACE"," ",335],"{",["T_WHITESPACE","\n          ",335],["T_VARIABLE","$result",336],"[",["T_VARIABLE","$key",336],"]",["T_WHITESPACE"," ",336],"=",["T_WHITESPACE"," ",336],["T_STRING","self",336],["T_DOUBLE_COLON","::",336],["T_STRING","mergeDeepArray",336],"(",["T_ARRAY","array",336],"(",["T_VARIABLE","$result",336],"[",["T_VARIABLE","$key",336],"]",",",["T_WHITESPACE"," ",336],["T_VARIABLE","$value",336],")",",",["T_WHITESPACE"," ",336],["T_VARIABLE","$preserve_integer_keys",336],")",";",["T_WHITESPACE","\n        ",336],"}",["T_WHITESPACE","\n        ",337],["T_COMMENT","\/\/ Otherwise, use the latter value, overriding any previous value.\n",338],["T_WHITESPACE","        ",339],["T_ELSE","else",339],["T_WHITESPACE"," ",339],"{",["T_WHITESPACE","\n          ",339],["T_VARIABLE","$result",340],"[",["T_VARIABLE","$key",340],"]",["T_WHITESPACE"," ",340],"=",["T_WHITESPACE"," ",340],["T_VARIABLE","$value",340],";",["T_WHITESPACE","\n        ",340],"}",["T_WHITESPACE","\n      ",341],"}",["T_WHITESPACE","\n    ",342],"}",["T_WHITESPACE","\n    ",343],["T_RETURN","return",344],["T_WHITESPACE"," ",344],["T_VARIABLE","$result",344],";",["T_WHITESPACE","\n  ",344],"}",["T_WHITESPACE","\n\n  ",345],["T_DOC_COMMENT","\/**\n   * Filters a nested array recursively.\n   *\n   * @param array $array\n   *   The filtered nested array.\n   * @param callable|null $callable\n   *   The callable to apply for filtering.\n   *\n   * @return array\n   *   The filtered array.\n   *\/",347],["T_WHITESPACE","\n  ",357],["T_PUBLIC","public",358],["T_WHITESPACE"," ",358],["T_STATIC","static",358],["T_WHITESPACE"," ",358],["T_FUNCTION","function",358],["T_WHITESPACE"," ",358],["T_STRING","filter",358],"(",["T_ARRAY","array",358],["T_WHITESPACE"," ",358],["T_VARIABLE","$array",358],",",["T_WHITESPACE"," ",358],["T_CALLABLE","callable",358],["T_WHITESPACE"," ",358],["T_VARIABLE","$callable",358],["T_WHITESPACE"," ",358],"=",["T_WHITESPACE"," ",358],["T_STRING","NULL",358],")",["T_WHITESPACE"," ",358],"{",["T_WHITESPACE","\n    ",358],["T_VARIABLE","$array",359],["T_WHITESPACE"," ",359],"=",["T_WHITESPACE"," ",359],["T_STRING","is_callable",359],"(",["T_VARIABLE","$callable",359],")",["T_WHITESPACE"," ",359],"?",["T_WHITESPACE"," ",359],["T_STRING","array_filter",359],"(",["T_VARIABLE","$array",359],",",["T_WHITESPACE"," ",359],["T_VARIABLE","$callable",359],")",["T_WHITESPACE"," ",359],":",["T_WHITESPACE"," ",359],["T_STRING","array_filter",359],"(",["T_VARIABLE","$array",359],")",";",["T_WHITESPACE","\n    ",359],["T_FOREACH","foreach",360],["T_WHITESPACE"," ",360],"(",["T_VARIABLE","$array",360],["T_WHITESPACE"," ",360],["T_AS","as",360],["T_WHITESPACE"," ",360],"&",["T_VARIABLE","$element",360],")",["T_WHITESPACE"," ",360],"{",["T_WHITESPACE","\n      ",360],["T_IF","if",361],["T_WHITESPACE"," ",361],"(",["T_STRING","is_array",361],"(",["T_VARIABLE","$element",361],")",")",["T_WHITESPACE"," ",361],"{",["T_WHITESPACE","\n        ",361],["T_VARIABLE","$element",362],["T_WHITESPACE"," ",362],"=",["T_WHITESPACE"," ",362],["T_STATIC","static",362],["T_DOUBLE_COLON","::",362],["T_STRING","filter",362],"(",["T_VARIABLE","$element",362],",",["T_WHITESPACE"," ",362],["T_VARIABLE","$callable",362],")",";",["T_WHITESPACE","\n      ",362],"}",["T_WHITESPACE","\n    ",363],"}",["T_WHITESPACE","\n\n    ",364],["T_RETURN","return",366],["T_WHITESPACE"," ",366],["T_VARIABLE","$array",366],";",["T_WHITESPACE","\n  ",366],"}",["T_WHITESPACE","\n\n",367],"}",["T_WHITESPACE","\n",369]]